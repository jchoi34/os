arch/mips/conf/ldscript:	 * Read-only loaded sections.
arch/mips/conf/ldscript:	/* linker-provided symbol for end of code */
arch/mips/conf/ldscript:	/* read-only data */
arch/mips/conf/ldscript:	/* MIPS register-usage blather */
arch/mips/conf/ldscript:	 * Move to a fresh page. This method puts read-only and
arch/mips/conf/ldscript:	 * read-write material on separate pages without having to
arch/mips/conf/ldscript:	 * waste space on page-alignment in the on-disk file; the
arch/mips/conf/ldscript:	 * on-disk page that contains both text and data is mapped
arch/mips/conf/ldscript:	 * For mips kernels we can't write-protect the text anyhow so
arch/mips/conf/ldscript:	 * Read-write loaded sections.
arch/mips/conf/ldscript:	/* cleared-to-zero data */
arch/mips/conf/ldscript:	/* linker-provided symbol for end of program */
arch/mips/conf/conf.arch:# 64-bit integer ops support for gcc
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/adddi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/anddi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/ashldi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/ashrdi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/cmpdi2.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/divdi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/iordi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/lshldi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/lshrdi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/moddi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/muldi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/negdi2.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/notdi2.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/qdivrem.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/subdi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/ucmpdi2.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/udivdi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/umoddi3.c
arch/mips/conf/conf.arch:machine mips file    ../common/gcc-millicode/xordi3.c
arch/mips/conf/conf.arch:# Low-level stuff ("locore")
arch/mips/conf/conf.arch:#    cache-mips1.S
arch/mips/conf/conf.arch:#    cache-mips161.S
arch/mips/conf/conf.arch:#    cache-mips32.S
arch/mips/conf/conf.arch:#    exception-mips1.S
arch/mips/conf/conf.arch:#    exception-mips32.S
arch/mips/conf/conf.arch:#    tlb-mips1.S
arch/mips/conf/conf.arch:#    tlb-mips161.S
arch/mips/conf/conf.arch:#    tlb-mips32.S
arch/mips/conf/conf.arch:# For the early assignments, we supply a very stupid MIPS-only skeleton
arch/mips/include/current.h: * - We misuse a kernel-settable field of a nonessential MMU register
arch/mips/include/current.h: * - On trap entry we use this number to index an array that gets us
arch/mips/include/current.h: * - We tell the compiler not to use the s7 register and keep
arch/mips/include/current.h: * places: here, the mips-specific kernel CFLAGS in the makefiles, and
arch/mips/include/elf.h: * MIPS machine-dependent definitions for the ELF binary format.
arch/mips/include/elf.h:#define R_MIPS_NONE	0	/* ---    nop */
arch/mips/include/elf.h:#define R_MIPS_LITERAL	8	/* s16    GPREL16 for file-local symbols (?) */
arch/mips/include/elf.h:#define R_MIPS_PC16	10	/* s16    PC-relative reference */
arch/mips/include/kern/endian.h: * Endianness. While the MIPS can be either big-endian (mipseb) or
arch/mips/include/kern/endian.h: * little-endian (mipsel), at least for now we only do mipseb.
arch/mips/include/kern/regdefs.h: * Macros for general-purpose register numbers for MIPS.
arch/mips/include/kern/regdefs.h:#define t0  $8     /* temporary (caller-save) 0 */
arch/mips/include/kern/regdefs.h:#define t1  $9     /* temporary (caller-save) 1 */
arch/mips/include/kern/regdefs.h:#define t2  $10    /* temporary (caller-save) 2 */
arch/mips/include/kern/regdefs.h:#define t3  $11    /* temporary (caller-save) 3 */
arch/mips/include/kern/regdefs.h:#define t4  $12    /* temporary (caller-save) 4 */
arch/mips/include/kern/regdefs.h:#define t5  $13    /* temporary (caller-save) 5 */
arch/mips/include/kern/regdefs.h:#define t6  $14    /* temporary (caller-save) 6 */
arch/mips/include/kern/regdefs.h:#define t7  $15    /* temporary (caller-save) 7 */
arch/mips/include/kern/regdefs.h:#define s0  $16    /* saved (callee-save) 0 */
arch/mips/include/kern/regdefs.h:#define s1  $17    /* saved (callee-save) 1 */
arch/mips/include/kern/regdefs.h:#define s2  $18    /* saved (callee-save) 2 */
arch/mips/include/kern/regdefs.h:#define s3  $19    /* saved (callee-save) 3 */
arch/mips/include/kern/regdefs.h:#define s4  $20    /* saved (callee-save) 4 */
arch/mips/include/kern/regdefs.h:#define s5  $21    /* saved (callee-save) 5 */
arch/mips/include/kern/regdefs.h:#define s6  $22    /* saved (callee-save) 6 */
arch/mips/include/kern/regdefs.h:#define s7  $23    /* saved (callee-save) 7 */
arch/mips/include/kern/regdefs.h:#define t8  $24    /* temporary (caller-save) 8 */
arch/mips/include/kern/regdefs.h:#define t9  $25    /* temporary (caller-save) 9 */
arch/mips/include/kern/regdefs.h:#define s8  $30    /* saved (callee-save) 8 = frame pointer */
arch/mips/include/kern/setjmp.h: * Must save: s0-s8, sp, ra (11 registers)
arch/mips/include/kern/signal.h: * userland signal handler - basically the saved register values from
arch/mips/include/kern/types.h: * Machine-dependent types visible to userland.
arch/mips/include/kern/types.h: * (Kernel-only types should go in mips/types.h.)
arch/mips/include/kern/types.h: * 32-bit MIPS version.
arch/mips/include/kern/types.h:typedef char      __i8;                 /* 8-bit signed integer */
arch/mips/include/kern/types.h:typedef short     __i16;                /* 16-bit signed integer */
arch/mips/include/kern/types.h:typedef int       __i32;                /* 32-bit signed integer */
arch/mips/include/kern/types.h:typedef long long __i64;                /* 64-bit signed integer */
arch/mips/include/kern/types.h:typedef unsigned char      __u8;        /* 8-bit unsigned integer */
arch/mips/include/kern/types.h:typedef unsigned short     __u16;       /* 16-bit unsigned integer */
arch/mips/include/kern/types.h:typedef unsigned int       __u32;       /* 32-bit unsigned integer */
arch/mips/include/kern/types.h:typedef unsigned long long __u64;       /* 64-bit unsigned integer */
arch/mips/include/kern/types.h:typedef long __intptr_t;                /* Signed pointer-sized integer */
arch/mips/include/kern/types.h:typedef unsigned long __uintptr_t;      /* Unsigned pointer-sized integer */
arch/mips/include/kern/types.h: * Since we're a 32-bit platform, size_t, ssize_t, and ptrdiff_t can
arch/mips/include/membar.h: * sparc, powerpc, etc.) We also mark the instruction as a compiler-
arch/mips/include/specialreg.h:#define c0_entrylo  $2          /* TLB entry contents (low-order half) */
arch/mips/include/specialreg.h:/*      c0_entrylo0 $2 */       /* MIPS-II and up only */
arch/mips/include/specialreg.h:/*      c0_entrylo1 $3 */       /* MIPS-II and up only */
arch/mips/include/specialreg.h:/*      c0_pagemask $5 */       /* MIPS-II and up only */
arch/mips/include/specialreg.h:/*      c0_wired    $6 */       /* MIPS-II and up only */
arch/mips/include/specialreg.h:#define c0_count    $9          /* cycle counter (MIPS-II and up) */
arch/mips/include/specialreg.h:#define c0_entryhi  $10         /* TLB entry contents (high-order half) */
arch/mips/include/specialreg.h:#define c0_compare  $11         /* on-chip timer control (MIPS-II and up) */
arch/mips/include/specialreg.h:/*      c0_config   $16 */      /* MIPS-II and up only */
arch/mips/include/specialreg.h:/*      c0_lladdr   $17 */      /* MIPS-II and up only */
arch/mips/include/specialreg.h:/*      c0_watchlo  $18 */      /* MIPS-II and up only */
arch/mips/include/specialreg.h:/*      c0_watchhi  $19 */      /* MIPS-II and up only */
arch/mips/include/specialreg.h:#define CIN_P      0x80000000   /* nonzero -> TLB probe found nothing */
arch/mips/include/specialreg.h:#define CIN_INDEX  0x00003f00   /* 6-bit index into TLB */
arch/mips/include/specialreg.h: * The intent of c0_context is that you can manage virtually-mapped
arch/mips/include/spinlock.h:	 * Test-and-set using LL/SC.
arch/mips/include/thread.h: * Machine-dependent thread bits.
arch/mips/include/tlb.h: * MIPS-specific TLB access functions.
arch/mips/include/tlb.h: *        ranges - these will never be matched.
arch/mips/include/tlb.h: * Note that the MIPS has support for a 6-bit address space ID. In the
arch/mips/include/tlb.h: * The TLBLO_DIRTY bit is actually a write privilege bit - it is not
arch/mips/include/tlb.h:/* Fields in the high-order word */
arch/mips/include/tlb.h:/* Fields in the low-order word */
arch/mips/include/trapframe.h: * This must agree with the code in exception-*.S.
arch/mips/include/trapframe.h:	uint32_t tf_k0;		/* dummy (see exception-mips1.S comments) */
arch/mips/include/trapframe.h:#define EX_MOD    1    /* TLB Modify (write to read-only page) */
arch/mips/include/types.h: * Machine-dependent types that are *not* made visible to userland.
arch/mips/include/types.h: * 32-bit MIPS version.
arch/mips/include/types.h: * file is included by types.h before the non-underscore versions are
arch/mips/include/vm.h: * Machine-dependent VM system definitions.
arch/mips/include/vm.h: * MIPS-I hardwired memory layout:
arch/mips/include/vm.h: *    0xc0000000 - 0xffffffff   kseg2 (kernel, tlb-mapped)
arch/mips/include/vm.h: *    0xa0000000 - 0xbfffffff   kseg1 (kernel, unmapped, uncached)
arch/mips/include/vm.h: *    0x80000000 - 0x9fffffff   kseg0 (kernel, unmapped, cached)
arch/mips/include/vm.h: *    0x00000000 - 0x7fffffff   kuseg (user, tlb-mapped)
arch/mips/include/vm.h:#define KVADDR_TO_PADDR(vaddr) ((vaddr)-MIPS_KSEG0)
arch/mips/include/vm.h: * the stack is subtract-then-store, this can start as the next
arch/mips/include/vm.h: * Interface to the low-level module that looks after the amount of
arch/mips/include/vm.h: * address. (This value is page-aligned.)  The extant RAM ranges from
arch/mips/include/vm.h: * also page-aligned.) Memory at this address and above is available
arch/mips/locore/cache-mips161.S:    * nasty on the MIPS-1, that is, r2000/r3000.)
arch/mips/locore/exception-mips1.S: * MIPS-1 (r2000/r3000) style exception handling, with the "rfe"
arch/mips/locore/exception-mips1.S: * This is the special entry point for the fast-path TLB refill for
arch/mips/locore/exception-mips1.S: * faults in the user address space. We don't implement fast-path TLB
arch/mips/locore/exception-mips1.S:   andi k0, k0, CST_KUp		/* Check the we-were-in-user-mode bit */
arch/mips/locore/exception-mips1.S:   /* Coming from user mode - find kernel stack */
arch/mips/locore/exception-mips1.S:   /* Coming from kernel mode - just save previous stuff */
arch/mips/locore/exception-mips1.S:    * one more for proper (64-bit) stack alignment.
arch/mips/locore/exception-mips1.S:   addi sp, sp, -168
arch/mips/locore/exception-mips1.S:    * currently expects -- or maybe even patch gdb to understand a
arch/mips/locore/exception-mips1.S:   andi k0, t2, CST_KUp		/* Check the we-were-in-user-mode bit */
arch/mips/locore/exception-mips1.S:   addiu a0, sp, 16             /* set argument - pointer to the trapframe */
arch/mips/locore/exception-mips1.S:   /*     152(sp)		   stack pointer - below */
arch/mips/locore/exception-mips1.S:    * Move it to the stack pointer - we don't need the actual stack
arch/mips/locore/exception-mips1.S:   addiu sp, a0, -16		/* in delay slot */
arch/mips/locore/trap.c:/* in exception-*.S */
arch/mips/locore/trap.c: * Function called when user-level code hits a fatal fault.
arch/mips/locore/trap.c: * This is called by the assembly-language exception handler once
arch/mips/locore/trap.c:	/*bool isutlb; -- not used */
arch/mips/locore/trap.c:	code = (tf->tf_cause & CCA_CODE) >> CCA_CODESHIFT;
arch/mips/locore/trap.c:	/*isutlb = (tf->tf_cause & CCA_UTLB) != 0;*/
arch/mips/locore/trap.c:	iskern = (tf->tf_status & CST_KUp) == 0;
arch/mips/locore/trap.c:	if (curthread != NULL && curthread->t_stack != NULL) {
arch/mips/locore/trap.c:		KASSERT((vaddr_t)tf > (vaddr_t)curthread->t_stack);
arch/mips/locore/trap.c:		KASSERT((vaddr_t)tf < (vaddr_t)(curthread->t_stack
arch/mips/locore/trap.c:		old_in = curthread->t_in_interrupt;
arch/mips/locore/trap.c:		curthread->t_in_interrupt = 1;
arch/mips/locore/trap.c:		if (curthread->t_curspl == 0) {
arch/mips/locore/trap.c:			KASSERT(curthread->t_curspl == 0);
arch/mips/locore/trap.c:			KASSERT(curthread->t_iplhigh_count == 0);
arch/mips/locore/trap.c:			curthread->t_curspl = IPL_HIGH;
arch/mips/locore/trap.c:			curthread->t_iplhigh_count++;
arch/mips/locore/trap.c:			KASSERT(curthread->t_curspl == IPL_HIGH);
arch/mips/locore/trap.c:			KASSERT(curthread->t_iplhigh_count == 1);
arch/mips/locore/trap.c:			curthread->t_iplhigh_count--;
arch/mips/locore/trap.c:			curthread->t_curspl = 0;
arch/mips/locore/trap.c:		curthread->t_in_interrupt = old_in;
arch/mips/locore/trap.c:		KASSERT(curthread->t_curspl == 0);
arch/mips/locore/trap.c:		KASSERT(curthread->t_iplhigh_count == 0);
arch/mips/locore/trap.c:		      tf->tf_v0, tf->tf_a0, tf->tf_a1, tf->tf_a2, tf->tf_a3);
arch/mips/locore/trap.c:		if (vm_fault(VM_FAULT_READONLY, tf->tf_vaddr)==0) {
arch/mips/locore/trap.c:		if (vm_fault(VM_FAULT_READ, tf->tf_vaddr)==0) {
arch/mips/locore/trap.c:		if (vm_fault(VM_FAULT_WRITE, tf->tf_vaddr)==0) {
arch/mips/locore/trap.c:		 * touched invalid parts of the direct-mapped
arch/mips/locore/trap.c:		panic("Bus error exception, PC=0x%x\n", tf->tf_epc);
arch/mips/locore/trap.c:	 * If we get to this point, it's a fatal fault - either it's
arch/mips/locore/trap.c:		kill_curthread(tf->tf_epc, code, tf->tf_vaddr);
arch/mips/locore/trap.c:	 * the addresses they're accessing are userlevel-supplied and
arch/mips/locore/trap.c:	 * This is accomplished by changing tf->tf_epc and returning
arch/mips/locore/trap.c:	    curthread->t_machdep.tm_badfaultfunc != NULL) {
arch/mips/locore/trap.c:		tf->tf_epc = (vaddr_t) curthread->t_machdep.tm_badfaultfunc;
arch/mips/locore/trap.c:	 * Really fatal kernel-mode fault.
arch/mips/locore/trap.c:		tf->tf_epc, tf->tf_vaddr);
arch/mips/locore/trap.c:	if (curthread->t_stack == NULL) {
arch/mips/locore/trap.c:	cputhreads[curcpu->c_number] = (vaddr_t)curthread;
arch/mips/locore/trap.c:	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
arch/mips/locore/trap.c:	 *   (1) curthread->t_stack is corrupted, or
arch/mips/locore/trap.c:	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
arch/mips/locore/trap.c: * This should not be used by threads returning from traps - they
arch/mips/locore/trap.c: * entering user mode for the first time - whether the child thread in
arch/mips/locore/trap.c: * a fork(), or into a brand-new address space after exec(), or when
arch/mips/locore/trap.c: *    - enter_new_process, for use by exec and equivalent.
arch/mips/locore/trap.c: *    - enter_forked_process, in syscall.c, for use by fork.
arch/mips/locore/trap.c:	 * be on. To interact properly with the spl-handling logic
arch/mips/locore/trap.c:	cputhreads[curcpu->c_number] = (vaddr_t)curthread;
arch/mips/locore/trap.c:	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
arch/mips/locore/trap.c:	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
arch/mips/locore/trap.c:	 * This actually does it. See exception-*.S.
arch/mips/locore/trap.c: * user-level address) and the environment pointer env (ditto), and
arch/mips/syscall/syscall.c: * exception-*.S) is passed in.
arch/mips/syscall/syscall.c: * function calls, the first 4 32-bit arguments are passed in the 4
arch/mips/syscall/syscall.c: * argument registers a0-a3. 64-bit arguments are passed in *aligned*
arch/mips/syscall/syscall.c: * if the first argument is 32-bit and the second is 64-bit, a1 is
arch/mips/syscall/syscall.c: * register, or v0 and v1 if 64-bit. This is also like an ordinary
arch/mips/syscall/syscall.c: * returning the value -1 from the actual userlevel syscall function.
arch/mips/syscall/syscall.c: * See src/user/lib/libc/arch/mips/syscalls-mips.S and related files.)
arch/mips/syscall/syscall.c: * If you run out of registers (which happens quickly with 64-bit
arch/mips/syscall/syscall.c: * values) further arguments must be fetched from the user-level
arch/mips/syscall/syscall.c:	KASSERT(curthread->t_curspl == 0);
arch/mips/syscall/syscall.c:	KASSERT(curthread->t_iplhigh_count == 0);
arch/mips/syscall/syscall.c:	callno = tf->tf_v0;
arch/mips/syscall/syscall.c:	 * really return a value, just 0 for success and -1 on
arch/mips/syscall/syscall.c:		err = sys_reboot(tf->tf_a0);
arch/mips/syscall/syscall.c:		err = sys___time((userptr_t)tf->tf_a0,
arch/mips/syscall/syscall.c:				 (userptr_t)tf->tf_a1);
arch/mips/syscall/syscall.c:			(userptr_t)tf->tf_a0,
arch/mips/syscall/syscall.c:			tf->tf_a1,
arch/mips/syscall/syscall.c:			tf->tf_a2,
arch/mips/syscall/syscall.c:			tf->tf_a0,
arch/mips/syscall/syscall.c:			tf->tf_a1,
arch/mips/syscall/syscall.c:		err = sys_close(tf->tf_a0);
arch/mips/syscall/syscall.c:			tf->tf_a0,
arch/mips/syscall/syscall.c:			(userptr_t)tf->tf_a1,
arch/mips/syscall/syscall.c:			tf->tf_a2,
arch/mips/syscall/syscall.c:			tf->tf_a0,
arch/mips/syscall/syscall.c:			(userptr_t)tf->tf_a1,
arch/mips/syscall/syscall.c:			tf->tf_a2,
arch/mips/syscall/syscall.c:			join32to64(tf->tf_a2, tf->tf_a3, &offset);
arch/mips/syscall/syscall.c:			err = copyin((userptr_t)tf->tf_sp + 16,
arch/mips/syscall/syscall.c:			err = sys_lseek(tf->tf_a0, offset, whence, &retval64);
arch/mips/syscall/syscall.c:			split64to32(retval64, &tf->tf_v0, &tf->tf_v1);
arch/mips/syscall/syscall.c:			retval = tf->tf_v0;
arch/mips/syscall/syscall.c:		err = sys_chdir((userptr_t)tf->tf_a0);
arch/mips/syscall/syscall.c:			(userptr_t)tf->tf_a0,
arch/mips/syscall/syscall.c:			tf->tf_a1,
arch/mips/syscall/syscall.c:			retval = sys_waitpid((pid_t)tf->tf_a0, (int *)tf->tf_a1, tf->tf_a2, &err);
arch/mips/syscall/syscall.c:			sys__exit(tf->tf_a0);
arch/mips/syscall/syscall.c:			sys_execv((char *)tf->tf_a0, (char **) tf->tf_a1, &err);
arch/mips/syscall/syscall.c:		 * userlevel to a return value of -1 and the error
arch/mips/syscall/syscall.c:		tf->tf_v0 = err;
arch/mips/syscall/syscall.c:		tf->tf_a3 = 1;      /* signal an error */
arch/mips/syscall/syscall.c:		tf->tf_v0 = retval;
arch/mips/syscall/syscall.c:		tf->tf_a3 = 0;      /* signal no error */
arch/mips/syscall/syscall.c:	tf->tf_epc += 4;
arch/mips/syscall/syscall.c:	KASSERT(curthread->t_curspl == 0);
arch/mips/syscall/syscall.c:	KASSERT(curthread->t_iplhigh_count == 0);
arch/mips/thread/cpu.c: * Startup and exception-time stack hook.
arch/mips/thread/cpu.c: * Do machine-dependent initialization of the cpu structure or things
arch/mips/thread/cpu.c:	KASSERT(c->c_number < MAXCPUS);
arch/mips/thread/cpu.c:	if (c->c_curthread->t_stack == NULL) {
arch/mips/thread/cpu.c:		stackpointer = (vaddr_t) c->c_curthread->t_stack;
arch/mips/thread/cpu.c:		cpustacks[c->c_number] = stackpointer;
arch/mips/thread/cpu.c:		cputhreads[c->c_number] = (vaddr_t)c->c_curthread;
arch/mips/thread/cpu.c: * System/161 processor-ID values.
arch/mips/thread/cpu.c:		snprintf(buf, max, "MIPS/161 (System/161 1.x and pre-2.x)");
arch/mips/thread/cpu.c:		snprintf(buf, max, "32-bit MIPS (unknown type, CPU ID 0x%x)",
arch/mips/thread/cpu.c: * While the mips actually has on-chip interrupt priority masking, in
arch/mips/thread/cpu.c: * (IEc stands for interrupt-enable-current.)
arch/mips/thread/cpu.c: *    - there must be at least one cycle between GET_STATUS
arch/mips/thread/cpu.c: *    - it may take up to three cycles after SET_STATUS for the
arch/mips/thread/switch.S:    *      s0-s6, s8
arch/mips/thread/switch.S:   addi sp, sp, -40
arch/mips/thread/thread_machdep.c:	tm->tm_badfaultfunc = NULL;
arch/mips/thread/thread_machdep.c:	KASSERT(tm->tm_badfaultfunc == NULL);
arch/mips/thread/threadstart.S: * Assembler-level thread startup trampoline.
arch/mips/thread/threadstart.S:    * Our arguments are in callee-save registers, as follows:
arch/mips/thread/threadstart.S:   addiu sp, sp, -16    /* make our stack frame */
arch/mips/thread/switchframe.c: * switchframe doesn't include the argument registers a0-a3. So we
arch/mips/thread/switchframe.c:        stacktop = ((vaddr_t)thread->t_stack) + STACK_SIZE;
arch/mips/thread/switchframe.c:        sf = ((struct switchframe *) stacktop) - 1;
arch/mips/thread/switchframe.c:        sf->sf_s0 = (uint32_t)entrypoint;
arch/mips/thread/switchframe.c:        sf->sf_s1 = (uint32_t)data1;
arch/mips/thread/switchframe.c:        sf->sf_s2 = (uint32_t)data2;
arch/mips/thread/switchframe.c:        sf->sf_ra = (uint32_t)mips_threadstart;
arch/mips/thread/switchframe.c:        /* Set ->t_context, and we're done. */
arch/mips/thread/switchframe.c:	thread->t_context = sf;
arch/mips/vm/tlb-mips161.S: * TLB handling for the MIPS-161.
arch/mips/vm/tlb-mips161.S: * The MIPS-161 uses the simpler MIPS-1 (r2000/r3000) TLB rather
arch/mips/vm/tlb-mips161.S: * than the paired-page TLB of later MIPS models.
arch/mips/vm/tlb-mips161.S: * a real MIPS-1, change the ssnops to plain nops and check where and
arch/mips/vm/tlb-mips161.S:    * into a (very pseudo-) random slot in the TLB.
arch/mips/vm/tlb-mips161.S:    * The high bit is not set <--> c0_index (now in t0) >= 0.
arch/mips/vm/tlb-mips161.S:   addi v0, z0, -1	/* set return value to -1 to indicate failure */
arch/mips/vm/tlb-mips161.S:   /* succeeded - get the index field from the index register value */
arch/mips/vm/tlb-mips161.S:   li t0, 0			/* t0 <- tlb index number (shifted) */
arch/mips/vm/tlb-mips161.S:   li t1, 0x81000000		/* t1 <- tlb reset vaddr */
arch/mips/vm/dumbvm.c: * Dumb MIPS-only "VM system" that is intended to only be just barely
arch/mips/vm/dumbvm.c:/* Allocate/free some kernel-space virtual pages */
arch/mips/vm/dumbvm.c:	/* nothing - leak the memory. */
arch/mips/vm/dumbvm.c:		/* We always create pages read-write, so we can't get this */
arch/mips/vm/dumbvm.c:	KASSERT(as->as_vbase1 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_pbase1 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_npages1 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_vbase2 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_pbase2 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_npages2 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_stackpbase != 0);
arch/mips/vm/dumbvm.c:	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
arch/mips/vm/dumbvm.c:	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
arch/mips/vm/dumbvm.c:	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
arch/mips/vm/dumbvm.c:	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
arch/mips/vm/dumbvm.c:	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
arch/mips/vm/dumbvm.c:	vbase1 = as->as_vbase1;
arch/mips/vm/dumbvm.c:	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
arch/mips/vm/dumbvm.c:	vbase2 = as->as_vbase2;
arch/mips/vm/dumbvm.c:	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
arch/mips/vm/dumbvm.c:	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
arch/mips/vm/dumbvm.c:		paddr = (faultaddress - vbase1) + as->as_pbase1;
arch/mips/vm/dumbvm.c:		paddr = (faultaddress - vbase2) + as->as_pbase2;
arch/mips/vm/dumbvm.c:		paddr = (faultaddress - stackbase) + as->as_stackpbase;
arch/mips/vm/dumbvm.c:	/* make sure it's page-aligned */
arch/mips/vm/dumbvm.c:		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
arch/mips/vm/dumbvm.c:	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
arch/mips/vm/dumbvm.c:	as->as_vbase1 = 0;
arch/mips/vm/dumbvm.c:	as->as_pbase1 = 0;
arch/mips/vm/dumbvm.c:	as->as_npages1 = 0;
arch/mips/vm/dumbvm.c:	as->as_vbase2 = 0;
arch/mips/vm/dumbvm.c:	as->as_pbase2 = 0;
arch/mips/vm/dumbvm.c:	as->as_npages2 = 0;
arch/mips/vm/dumbvm.c:	as->as_stackpbase = 0;
arch/mips/vm/dumbvm.c:	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
arch/mips/vm/dumbvm.c:	/* We don't use these - all pages are read-write */
arch/mips/vm/dumbvm.c:	if (as->as_vbase1 == 0) {
arch/mips/vm/dumbvm.c:		as->as_vbase1 = vaddr;
arch/mips/vm/dumbvm.c:		as->as_npages1 = npages;
arch/mips/vm/dumbvm.c:	if (as->as_vbase2 == 0) {
arch/mips/vm/dumbvm.c:		as->as_vbase2 = vaddr;
arch/mips/vm/dumbvm.c:		as->as_npages2 = npages;
arch/mips/vm/dumbvm.c:	KASSERT(as->as_pbase1 == 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_pbase2 == 0);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_stackpbase == 0);
arch/mips/vm/dumbvm.c:	as->as_pbase1 = getppages(as->as_npages1);
arch/mips/vm/dumbvm.c:	if (as->as_pbase1 == 0) {
arch/mips/vm/dumbvm.c:	as->as_pbase2 = getppages(as->as_npages2);
arch/mips/vm/dumbvm.c:	if (as->as_pbase2 == 0) {
arch/mips/vm/dumbvm.c:	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
arch/mips/vm/dumbvm.c:	if (as->as_stackpbase == 0) {
arch/mips/vm/dumbvm.c:	as_zero_region(as->as_pbase1, as->as_npages1);
arch/mips/vm/dumbvm.c:	as_zero_region(as->as_pbase2, as->as_npages2);
arch/mips/vm/dumbvm.c:	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
arch/mips/vm/dumbvm.c:	KASSERT(as->as_stackpbase != 0);
arch/mips/vm/dumbvm.c:	new->as_vbase1 = old->as_vbase1;
arch/mips/vm/dumbvm.c:	new->as_npages1 = old->as_npages1;
arch/mips/vm/dumbvm.c:	new->as_vbase2 = old->as_vbase2;
arch/mips/vm/dumbvm.c:	new->as_npages2 = old->as_npages2;
arch/mips/vm/dumbvm.c:	KASSERT(new->as_pbase1 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(new->as_pbase2 != 0);
arch/mips/vm/dumbvm.c:	KASSERT(new->as_stackpbase != 0);
arch/mips/vm/dumbvm.c:	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
arch/mips/vm/dumbvm.c:		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
arch/mips/vm/dumbvm.c:		old->as_npages1*PAGE_SIZE);
arch/mips/vm/dumbvm.c:	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
arch/mips/vm/dumbvm.c:		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
arch/mips/vm/dumbvm.c:		old->as_npages2*PAGE_SIZE);
arch/mips/vm/dumbvm.c:	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
arch/mips/vm/dumbvm.c:		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
arch/mips/vm/ram.c:	firstpaddr = firstfree - MIPS_KSEG0;
arch/mips/vm/ram.c:		(lastpaddr-firstpaddr)/1024);
arch/mips/vm/ram.c:	return lastpaddr - firstpaddr;
arch/mips/vm/vm.c:	VM_STACKPAGES -= (size/PAGE_SIZE);
arch/mips/vm/vm.c:				unsigned int first_block = i - (npages - 1);
arch/mips/vm/vm.c:		temp->state = unused;
arch/mips/vm/vm.c:		temp = temp->next;	
arch/mips/vm/vm.c:        KASSERT(as->as_vbase1 != 0);
arch/mips/vm/vm.c:        KASSERT(as->as_pbase1 != 0);
arch/mips/vm/vm.c:        KASSERT(as->as_npages1 != 0);
arch/mips/vm/vm.c:        KASSERT(as->as_stackpbase != 0);
arch/mips/vm/vm.c:        KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
arch/mips/vm/vm.c:        KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
arch/mips/vm/vm.c:        KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
arch/mips/vm/vm.c:	vbase1 = as->as_vbase1;
arch/mips/vm/vm.c:        vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
arch/mips/vm/vm.c:        stackbase = USERSTACK - VM_STACKPAGES * PAGE_SIZE;
arch/mips/vm/vm.c:                paddr = (faultaddress - vbase1) + as->as_pbase1;
arch/mips/vm/vm.c:                paddr = (faultaddress - stackbase) + as->as_stackpbase;
arch/mips/vm/vm.c:        /* make sure it's page-aligned */
arch/mips/vm/vm.c:                DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
arch/sys161/conf/conf.arch:# Platform-dependent sources for System/161.
arch/sys161/conf/conf.arch:platform sys161 file    arch/mips/locore/cache-mips161.S
arch/sys161/conf/conf.arch:platform sys161 file    arch/mips/locore/exception-mips1.S
arch/sys161/conf/conf.arch:platform sys161 file    arch/mips/vm/tlb-mips161.S
arch/sys161/dev/lamebus_machdep.c: * CPU frequency used by the on-chip timer.
arch/sys161/dev/lamebus_machdep.c: * real-time clock instead of compiling it in like this.
arch/sys161/dev/lamebus_machdep.c: * Access to the on-chip timer.
arch/sys161/dev/lamebus_machdep.c:	KASSERT(curthread->t_curspl > 0);
arch/sys161/dev/lamebus_machdep.c:	 * Configure the MIPS on-chip timer to interrupt HZ times a second.
arch/sys161/dev/lamebus_machdep.c: * Read a 32-bit register from a LAMEbus device.
arch/sys161/dev/lamebus_machdep.c: * Write a 32-bit register of a LAMEbus device.
arch/sys161/dev/lamebus_machdep.c:	 * The MIPS doesn't appear to have any on-chip reset.
arch/sys161/dev/lamebus_machdep.c:	kprintf("Cannot reboot - powering off instead, sorry.\n");
arch/sys161/dev/lamebus_machdep.c:#define LAMEBUS_IPI_BIT  0x00000800	/* inter-processor interrupt */
arch/sys161/dev/lamebus_machdep.c:#define MIPS_TIMER_BIT   0x00008000	/* on-chip timer */
arch/sys161/dev/lamebus_machdep.c:	KASSERT(curthread->t_curspl > 0);
arch/sys161/dev/lamebus_machdep.c:	cause = tf->tf_cause;
arch/sys161/include/bus.h: * Machine-dependent LAMEbus definitions
arch/sys161/include/maxcpus.h: * fixed-size per-cpu array in the data segment. This is
arch/sys161/include/maxcpus.h: * platform-dependent rather than processor-dependent because there's
arch/sys161/main/start.S:    * and we have to align to an 8-byte (64-bit) boundary, so the
arch/sys161/main/start.S:   .frame sp, 24, $0	/* 24-byte sp-relative frame; return addr on stack */
arch/sys161/main/start.S:   .mask 0x80000000, -4	/* register 31 (ra) saved at (sp+24)-4 */
arch/sys161/main/start.S:   addiu sp, sp, -24
arch/sys161/main/start.S:   addiu sp, sp, -24
arch/sys161/main/start.S:    * don't use this feature (for simplicity) - we only use the master
arch/sys161/main/start.S:    * instead of the two it takes to set up a full 32-bit address.
arch/sys161/main/start.S:    * controller per-CPU space. This means we can, with a bit of
arch/sys161/main/start.S:   .frame sp, 24, $0	/* 24-byte sp-relative frame; return addr on stack */
arch/sys161/main/start.S:   .mask 0x80000000, -4	/* register 31 (ra) saved at (sp+24)-4 */
arch/sys161/main/start.S:   addiu sp, sp, -24
arch/sys161/main/start.S:    * Initialize the on-chip timer interrupt.
arch/sys161/main/start.S:   addiu sp, sp, -24
compile/ASST3/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h ../../compile/ASST3/autoconf.h
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST3/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST3/.depend:  opt-noasserts.h
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST3/.depend:  ../../include/syscall.h ../../include/test.h opt-synchprobs.h opt-sfs.h \
compile/ASST3/.depend:  opt-net.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST3/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-dumbvm.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/synch.h ../../include/test.h opt-synchprobs.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-dumbvm.h ../../include/mainbus.h ../../include/vnode.h \
compile/ASST3/.depend:  opt-synchprobs.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST3/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:  opt-dumbvm.h
compile/ASST3/.depend:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST3/.depend:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST3/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST3/.depend:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST3/.depend:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST3/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST3/.depend.__printf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST3/.depend.snprintf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST3/.depend.atoi.c:  opt-noasserts.h
compile/ASST3/.depend.bzero.c:  opt-noasserts.h
compile/ASST3/.depend.memcpy.c:  opt-noasserts.h
compile/ASST3/.depend.memmove.c:  opt-noasserts.h
compile/ASST3/.depend.memset.c:  opt-noasserts.h
compile/ASST3/.depend.strcat.c:  opt-noasserts.h
compile/ASST3/.depend.strchr.c:  opt-noasserts.h
compile/ASST3/.depend.strcmp.c:  opt-noasserts.h
compile/ASST3/.depend.strcpy.c:  opt-noasserts.h
compile/ASST3/.depend.strlen.c:  opt-noasserts.h
compile/ASST3/.depend.strrchr.c:  opt-noasserts.h
compile/ASST3/.depend.strtok_r.c:  opt-noasserts.h
compile/ASST3/.depend.autoconf.c:  opt-noasserts.h ../../compile/ASST3/autoconf.h
compile/ASST3/.depend.beep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.console.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.random.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST3/.depend.rtclock.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.beep_ltimer.c:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST3/.depend.con_lser.c:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST3/.depend.emu_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend.emu.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.lamebus.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend.lhd_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend.lhd.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.lrandom_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend.lrandom.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST3/.depend.lser_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend.lser.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST3/.depend.ltimer_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend.ltimer.c:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST3/.depend.ltrace_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST3/.depend.ltrace.c:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST3/.depend.random_lrandom.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.rtclock_ltimer.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.semfs_fsops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST3/.depend.semfs_obj.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST3/.depend.semfs_vnops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST3/.depend.sfs_balloc.c:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST3/.depend.sfs_bmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.sfs_dir.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.sfs_fsops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.sfs_inode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.sfs_io.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.sfs_vnops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.array.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.bitmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.kgets.c:  opt-noasserts.h
compile/ASST3/.depend.kprintf.c:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST3/.depend.misc.c:  opt-noasserts.h
compile/ASST3/.depend.uio.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.main.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.menu.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST3/.depend.menu.c:  ../../include/syscall.h ../../include/test.h opt-synchprobs.h opt-sfs.h \
compile/ASST3/.depend.menu.c:  opt-net.h
compile/ASST3/.depend.proc.c:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST3/.depend.proc.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST3/.depend.bathroom.c:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST3/.depend.whalemating.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend.file_syscalls.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST3/.depend.filetable.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.loadelf.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.loadelf.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST3/.depend.openfile.c:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST3/.depend.runprogram.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.runprogram.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST3/.depend.arraytest.c:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST3/.depend.bitmaptest.c:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST3/.depend.fstest.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST3/.depend.kmalloctest.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.kmalloctest.c:  opt-dumbvm.h
compile/ASST3/.depend.synchtest.c:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST3/.depend.threadlisttest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend.threadtest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend.tt3.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.tt3.c:  ../../include/synch.h ../../include/test.h opt-synchprobs.h
compile/ASST3/.depend.clock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend.spinlock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend.spl.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST3/.depend.synch.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST3/.depend.thread.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.thread.c:  opt-dumbvm.h ../../include/mainbus.h ../../include/vnode.h \
compile/ASST3/.depend.thread.c:  opt-synchprobs.h
compile/ASST3/.depend.threadlist.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend.device.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.devnull.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.vfscwd.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST3/.depend.vfslist.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.vfslookup.c:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST3/.depend.vfspath.c:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST3/.depend.vnode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.kmalloc.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST3/.depend.trap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.syscall.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.cpu.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST3/.depend.switchframe.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST3/.depend.thread_machdep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.dumbvm.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.dumbvm.c:  opt-dumbvm.h
compile/ASST3/.depend.ram.c:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST3/.depend.adddi3.c:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST3/.depend.adddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.anddi3.c:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST3/.depend.anddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.ashldi3.c:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST3/.depend.ashldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.ashrdi3.c:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST3/.depend.ashrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.cmpdi2.c:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST3/.depend.cmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.divdi3.c:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST3/.depend.divdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.iordi3.c:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST3/.depend.iordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.lshldi3.c:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST3/.depend.lshldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.lshrdi3.c:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST3/.depend.lshrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.moddi3.c:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST3/.depend.moddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.muldi3.c:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST3/.depend.muldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.negdi2.c:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST3/.depend.negdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.notdi2.c:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST3/.depend.notdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.qdivrem.c:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST3/.depend.qdivrem.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.subdi3.c:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST3/.depend.subdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.ucmpdi2.c:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST3/.depend.ucmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.udivdi3.c:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST3/.depend.udivdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.umoddi3.c:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST3/.depend.umoddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.xordi3.c:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST3/.depend.xordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST3/.depend.copyinout.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST3/.depend.cache-mips161.S:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST3/.depend.exception-mips1.S:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST3/Makefile:KDEBUG=-g
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/autoconf.c:		return -1;
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/adddi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/anddi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashldi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashrdi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/cmpdi2.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/divdi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/iordi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshldi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshrdi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/moddi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/muldi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/negdi2.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/notdi2.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/qdivrem.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/subdi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ucmpdi2.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/udivdi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/umoddi3.c
compile/ASST3/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/xordi3.c
compile/ASST3/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/cache-mips161.S
compile/ASST3/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/exception-mips1.S
compile/ASST3/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/vm/tlb-mips161.S
compile/ASST3/.depend.tlb-mips161.S:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST3/.depend.lamebus_machdep.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4a/.depend.ram.c:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST4a/.depend.anddi3.c:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST4a/.depend.anddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.ashrdi3.c:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST4a/.depend.ashrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.divdi3.c:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST4a/.depend.divdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.lshldi3.c:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST4a/.depend.lshldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.moddi3.c:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST4a/.depend.moddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.negdi2.c:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST4a/.depend.negdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/adddi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/anddi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashldi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashrdi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/cmpdi2.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/divdi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/iordi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshldi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshrdi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/moddi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/muldi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/negdi2.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/notdi2.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/qdivrem.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/subdi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ucmpdi2.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/udivdi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/umoddi3.c
compile/ASST4a/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/xordi3.c
compile/ASST4a/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/cache-mips161.S
compile/ASST4a/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/exception-mips1.S
compile/ASST4a/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/vm/tlb-mips161.S
compile/ASST4a/Makefile:KDEBUG=-g
compile/ASST4a/.depend.notdi2.c:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST4a/.depend.notdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/autoconf.c:		return -1;
compile/ASST4a/.depend.__printf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4a/.depend.snprintf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4a/.depend.atoi.c:  opt-noasserts.h
compile/ASST4a/.depend.bzero.c:  opt-noasserts.h
compile/ASST4a/.depend.memcpy.c:  opt-noasserts.h
compile/ASST4a/.depend.memmove.c:  opt-noasserts.h
compile/ASST4a/.depend.memset.c:  opt-noasserts.h
compile/ASST4a/.depend.strcat.c:  opt-noasserts.h
compile/ASST4a/.depend.strchr.c:  opt-noasserts.h
compile/ASST4a/.depend.strcmp.c:  opt-noasserts.h
compile/ASST4a/.depend.strcpy.c:  opt-noasserts.h
compile/ASST4a/.depend.strlen.c:  opt-noasserts.h
compile/ASST4a/.depend.strrchr.c:  opt-noasserts.h
compile/ASST4a/.depend.strtok_r.c:  opt-noasserts.h
compile/ASST4a/.depend.autoconf.c:  opt-noasserts.h ../../compile/ASST4a/autoconf.h
compile/ASST4a/.depend.beep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.console.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.random.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4a/.depend.rtclock.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.beep_ltimer.c:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST4a/.depend.con_lser.c:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST4a/.depend.emu_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend.emu.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.lamebus.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend.lhd_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend.lhd.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.lrandom_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend.lrandom.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4a/.depend.lser_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend.lser.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend.ltimer_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend.ltimer.c:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST4a/.depend.ltrace_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend.ltrace.c:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST4a/.depend.random_lrandom.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.rtclock_ltimer.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.semfs_fsops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend.semfs_obj.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend.semfs_vnops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend.sfs_balloc.c:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST4a/.depend.sfs_bmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.sfs_dir.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.sfs_fsops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.sfs_inode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.sfs_io.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.sfs_vnops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.array.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.bitmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.kgets.c:  opt-noasserts.h
compile/ASST4a/.depend.kprintf.c:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST4a/.depend.misc.c:  opt-noasserts.h
compile/ASST4a/.depend.uio.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.main.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.menu.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4a/.depend.menu.c:  ../../include/test.h opt-synchprobs.h opt-sfs.h opt-net.h
compile/ASST4a/.depend.proc.c:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST4a/.depend.proc.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4a/.depend.exit.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend.file_syscalls.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4a/.depend.filetable.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.fork.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend.fork.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h
compile/ASST4a/.depend.getpid.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend.loadelf.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.loadelf.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4a/.depend.openfile.c:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST4a/.depend.runprogram.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.runprogram.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4a/.depend.waitpid.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend.arraytest.c:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST4a/.depend.bitmaptest.c:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST4a/.depend.fstest.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4a/.depend.kmalloctest.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.kmalloctest.c:  opt-dumbvm.h
compile/ASST4a/.depend.synchtest.c:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST4a/.depend.threadlisttest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend.threadtest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend.tt3.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.tt3.c:  ../../include/synch.h ../../include/test.h opt-synchprobs.h
compile/ASST4a/.depend.clock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend.spinlock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend.spl.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend.synch.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend.thread.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.thread.c:  ../../include/addrspace.h ../../include/vm.h opt-dumbvm.h \
compile/ASST4a/.depend.thread.c:  ../../include/mainbus.h ../../include/vnode.h opt-synchprobs.h
compile/ASST4a/.depend.threadlist.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend.device.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.devnull.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.vfscwd.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4a/.depend.vfslist.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.vfslookup.c:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST4a/.depend.vfspath.c:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST4a/.depend.vnode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.kmalloc.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend.trap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.syscall.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.cpu.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4a/.depend.switchframe.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend.thread_machdep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.dumbvm.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.dumbvm.c:  opt-dumbvm.h
compile/ASST4a/.depend.adddi3.c:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST4a/.depend.adddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.ashldi3.c:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST4a/.depend.ashldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.cmpdi2.c:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST4a/.depend.cmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.iordi3.c:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST4a/.depend.iordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.lshrdi3.c:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST4a/.depend.lshrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.muldi3.c:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST4a/.depend.muldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.qdivrem.c:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST4a/.depend.qdivrem.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.subdi3.c:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST4a/.depend.subdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.ucmpdi2.c:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST4a/.depend.ucmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.udivdi3.c:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST4a/.depend.udivdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.umoddi3.c:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST4a/.depend.umoddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.xordi3.c:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST4a/.depend.xordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend.copyinout.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend.cache-mips161.S:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST4a/.depend.exception-mips1.S:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST4a/.depend.tlb-mips161.S:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST4a/.depend.lamebus_machdep.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h ../../compile/ASST4a/autoconf.h
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4a/.depend:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST4a/.depend:  opt-noasserts.h
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4a/.depend:  ../../include/test.h opt-synchprobs.h opt-sfs.h opt-net.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST4a/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4a/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4a/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-dumbvm.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/synch.h ../../include/test.h opt-synchprobs.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/addrspace.h ../../include/vm.h opt-dumbvm.h \
compile/ASST4a/.depend:  ../../include/mainbus.h ../../include/vnode.h opt-synchprobs.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4a/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:  opt-dumbvm.h
compile/ASST4a/.depend:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST4a/.depend:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST4a/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4a/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4a/.depend:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST4a/.depend:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST4a/.depend:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST4a/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4b/.depend.dumbvm.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.dumbvm.c:  opt-dumbvm.h
compile/ASST4b/.depend.adddi3.c:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST4b/.depend.adddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.ashldi3.c:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST4b/.depend.ashldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.cmpdi2.c:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST4b/.depend.cmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.iordi3.c:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST4b/.depend.iordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.lshrdi3.c:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST4b/.depend.lshrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.muldi3.c:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST4b/.depend.muldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/adddi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/anddi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashldi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashrdi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/cmpdi2.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/divdi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/iordi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshldi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshrdi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/moddi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/muldi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/negdi2.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/notdi2.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/qdivrem.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/subdi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ucmpdi2.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/udivdi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/umoddi3.c
compile/ASST4b/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/xordi3.c
compile/ASST4b/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/cache-mips161.S
compile/ASST4b/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/exception-mips1.S
compile/ASST4b/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/vm/tlb-mips161.S
compile/ASST4b/Makefile:KDEBUG=-g
compile/ASST4b/.depend.negdi2.c:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST4b/.depend.negdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/autoconf.c:		return -1;
compile/ASST4b/.depend.__printf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4b/.depend.snprintf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4b/.depend.atoi.c:  opt-noasserts.h
compile/ASST4b/.depend.bzero.c:  opt-noasserts.h
compile/ASST4b/.depend.memcpy.c:  opt-noasserts.h
compile/ASST4b/.depend.memmove.c:  opt-noasserts.h
compile/ASST4b/.depend.memset.c:  opt-noasserts.h
compile/ASST4b/.depend.strcat.c:  opt-noasserts.h
compile/ASST4b/.depend.strchr.c:  opt-noasserts.h
compile/ASST4b/.depend.strcmp.c:  opt-noasserts.h
compile/ASST4b/.depend.strcpy.c:  opt-noasserts.h
compile/ASST4b/.depend.strlen.c:  opt-noasserts.h
compile/ASST4b/.depend.strrchr.c:  opt-noasserts.h
compile/ASST4b/.depend.strtok_r.c:  opt-noasserts.h
compile/ASST4b/.depend.autoconf.c:  opt-noasserts.h ../../compile/ASST4b/autoconf.h
compile/ASST4b/.depend.beep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.console.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.random.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4b/.depend.rtclock.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.beep_ltimer.c:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST4b/.depend.con_lser.c:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST4b/.depend.emu_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend.emu.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.lamebus.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend.lhd_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend.lhd.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.lrandom_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend.lrandom.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4b/.depend.lser_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend.lser.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend.ltimer_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend.ltimer.c:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST4b/.depend.ltrace_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend.ltrace.c:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST4b/.depend.random_lrandom.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.rtclock_ltimer.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.semfs_fsops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend.semfs_obj.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend.semfs_vnops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend.sfs_balloc.c:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST4b/.depend.sfs_bmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.sfs_dir.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.sfs_fsops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.sfs_inode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.sfs_io.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.sfs_vnops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.array.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.bitmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.kgets.c:  opt-noasserts.h
compile/ASST4b/.depend.kprintf.c:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST4b/.depend.misc.c:  opt-noasserts.h
compile/ASST4b/.depend.uio.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.main.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.menu.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4b/.depend.menu.c:  ../../include/test.h opt-synchprobs.h opt-sfs.h opt-net.h
compile/ASST4b/.depend.proc.c:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST4b/.depend.proc.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend.execv.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.execv.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend.exit.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend.exit.c:  opt-dumbvm.h
compile/ASST4b/.depend.file_syscalls.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4b/.depend.filetable.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.fork.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend.fork.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h
compile/ASST4b/.depend.getpid.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend.loadelf.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.loadelf.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend.openfile.c:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST4b/.depend.runprogram.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.runprogram.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend.waitpid.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend.arraytest.c:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST4b/.depend.bitmaptest.c:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST4b/.depend.fstest.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4b/.depend.kmalloctest.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.kmalloctest.c:  includelinks/machine/vm.h ../../include/test.h opt-dumbvm.h
compile/ASST4b/.depend.synchtest.c:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST4b/.depend.threadlisttest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend.threadtest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend.tt3.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.tt3.c:  ../../include/kern/limits.h ../../include/test.h opt-synchprobs.h
compile/ASST4b/.depend.clock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend.spinlock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend.spl.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend.synch.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend.thread.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.thread.c:  ../../include/addrspace.h ../../include/vm.h opt-dumbvm.h \
compile/ASST4b/.depend.thread.c:  ../../include/mainbus.h ../../include/vnode.h opt-synchprobs.h
compile/ASST4b/.depend.threadlist.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend.device.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.devnull.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.vfscwd.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4b/.depend.vfslist.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.vfslookup.c:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST4b/.depend.vfspath.c:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST4b/.depend.vnode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.kmalloc.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend.trap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.syscall.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.cpu.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4b/.depend.switchframe.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend.thread_machdep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.ram.c:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST4b/.depend.anddi3.c:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST4b/.depend.anddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.ashrdi3.c:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST4b/.depend.ashrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.divdi3.c:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST4b/.depend.divdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.lshldi3.c:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST4b/.depend.lshldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.moddi3.c:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST4b/.depend.moddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.notdi2.c:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST4b/.depend.notdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.qdivrem.c:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST4b/.depend.qdivrem.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.subdi3.c:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST4b/.depend.subdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.ucmpdi2.c:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST4b/.depend.ucmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.udivdi3.c:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST4b/.depend.udivdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.umoddi3.c:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST4b/.depend.umoddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.cache-mips161.S:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST4b/.depend.tlb-mips161.S:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h ../../compile/ASST4b/autoconf.h
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST4b/.depend:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST4b/.depend:  opt-noasserts.h
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4b/.depend:  ../../include/test.h opt-synchprobs.h opt-sfs.h opt-net.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST4b/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-dumbvm.h
compile/ASST4b/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST4b/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  includelinks/machine/vm.h ../../include/test.h opt-dumbvm.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/kern/limits.h ../../include/test.h opt-synchprobs.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/addrspace.h ../../include/vm.h opt-dumbvm.h \
compile/ASST4b/.depend:  ../../include/mainbus.h ../../include/vnode.h opt-synchprobs.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4b/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:  opt-dumbvm.h
compile/ASST4b/.depend:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST4b/.depend:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST4b/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST4b/.depend:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST4b/.depend:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST4b/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST4b/.depend.xordi3.c:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST4b/.depend.xordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST4b/.depend.copyinout.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST4b/.depend.exception-mips1.S:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST4b/.depend.lamebus_machdep.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST5/.depend.ltimer.c:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST5/.depend.ltrace.c:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST5/.depend.rtclock_ltimer.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.semfs_obj.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.sfs_balloc.c:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST5/.depend.sfs_dir.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/adddi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/anddi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashldi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ashrdi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/cmpdi2.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/divdi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/iordi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshldi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/lshrdi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/moddi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/muldi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/negdi2.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/notdi2.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/qdivrem.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/subdi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/ucmpdi2.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/udivdi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/umoddi3.c
compile/ASST5/files.mk:SRCS.MACHINE.mips+=$(TOP)/common/gcc-millicode/xordi3.c
compile/ASST5/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/cache-mips161.S
compile/ASST5/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/locore/exception-mips1.S
compile/ASST5/files.mk:SRCS.PLATFORM.sys161+=$(KTOP)/arch/mips/vm/tlb-mips161.S
compile/ASST5/Makefile:KDEBUG=-g
compile/ASST5/.depend.sfs_fsops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/autoconf.c:		return -1;
compile/ASST5/.depend.__printf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST5/.depend.snprintf.c:  opt-noasserts.h ../../include/stdarg.h
compile/ASST5/.depend.atoi.c:  opt-noasserts.h
compile/ASST5/.depend.bzero.c:  opt-noasserts.h
compile/ASST5/.depend.memcpy.c:  opt-noasserts.h
compile/ASST5/.depend.memmove.c:  opt-noasserts.h
compile/ASST5/.depend.memset.c:  opt-noasserts.h
compile/ASST5/.depend.strcat.c:  opt-noasserts.h
compile/ASST5/.depend.strchr.c:  opt-noasserts.h
compile/ASST5/.depend.strcmp.c:  opt-noasserts.h
compile/ASST5/.depend.strcpy.c:  opt-noasserts.h
compile/ASST5/.depend.strlen.c:  opt-noasserts.h
compile/ASST5/.depend.strrchr.c:  opt-noasserts.h
compile/ASST5/.depend.strtok_r.c:  opt-noasserts.h
compile/ASST5/.depend.autoconf.c:  opt-noasserts.h ../../compile/ASST5/autoconf.h
compile/ASST5/.depend.beep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.console.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.random.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST5/.depend.rtclock.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.beep_ltimer.c:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST5/.depend.con_lser.c:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST5/.depend.emu_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend.emu.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.lamebus.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend.lhd_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend.lhd.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.lrandom_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend.lrandom.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST5/.depend.lser_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend.lser.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend.ltimer_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend.ltrace_att.c:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend.random_lrandom.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.semfs_fsops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.semfs_vnops.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.sfs_bmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.sfs_inode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.sfs_io.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.sfs_vnops.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.array.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.bitmap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.kgets.c:  opt-noasserts.h
compile/ASST5/.depend.kprintf.c:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST5/.depend.misc.c:  opt-noasserts.h
compile/ASST5/.depend.uio.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.main.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.menu.c:  ../../include/cdefs.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.menu.c:  ../../include/test.h opt-synchprobs.h opt-sfs.h opt-net.h
compile/ASST5/.depend.proc.c:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST5/.depend.proc.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend.execv.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.execv.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend.exit.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.exit.c:  opt-dumbvm.h
compile/ASST5/.depend.file_syscalls.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST5/.depend.filetable.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.fork.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.fork.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h
compile/ASST5/.depend.getpid.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend.loadelf.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.loadelf.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend.openfile.c:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST5/.depend.runprogram.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.runprogram.c:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend.waitpid.c:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend.arraytest.c:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST5/.depend.bitmaptest.c:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST5/.depend.fstest.c:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST5/.depend.kmalloctest.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.kmalloctest.c:  includelinks/machine/vm.h ../../include/test.h opt-dumbvm.h
compile/ASST5/.depend.synchtest.c:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST5/.depend.threadlisttest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend.threadtest.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend.tt3.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.tt3.c:  ../../include/kern/limits.h ../../include/test.h opt-synchprobs.h
compile/ASST5/.depend.clock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend.spinlock.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend.spl.c:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend.synch.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend.thread.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.thread.c:  ../../include/addrspace.h ../../include/vm.h opt-dumbvm.h \
compile/ASST5/.depend.thread.c:  ../../include/mainbus.h ../../include/vnode.h opt-synchprobs.h
compile/ASST5/.depend.threadlist.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend.device.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.devnull.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.vfscwd.c:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST5/.depend.vfslist.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.vfslookup.c:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST5/.depend.vfspath.c:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST5/.depend.vnode.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.addrspace.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.addrspace.c:  opt-dumbvm.h ../../include/proc.h ../../include/spinlock.h \
compile/ASST5/.depend.kmalloc.c:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend.trap.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.syscall.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.cpu.c:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST5/.depend.switchframe.c:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend.thread_machdep.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.ram.c:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST5/.depend.vm.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.vm.c:  opt-dumbvm.h
compile/ASST5/.depend.adddi3.c:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST5/.depend.adddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.anddi3.c:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST5/.depend.anddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.ashldi3.c:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST5/.depend.ashldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.ashrdi3.c:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST5/.depend.ashrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.cmpdi2.c:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST5/.depend.cmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.divdi3.c:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST5/.depend.divdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.iordi3.c:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST5/.depend.iordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.lshldi3.c:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST5/.depend.lshldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.lshrdi3.c:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST5/.depend.lshrdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.moddi3.c:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST5/.depend.moddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.muldi3.c:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST5/.depend.muldi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.negdi2.c:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST5/.depend.negdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.notdi2.c:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST5/.depend.notdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.qdivrem.c:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST5/.depend.qdivrem.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.subdi3.c:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST5/.depend.subdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.ucmpdi2.c:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST5/.depend.ucmpdi2.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.udivdi3.c:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST5/.depend.udivdi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.umoddi3.c:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST5/.depend.umoddi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.cache-mips161.S:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST5/.depend.tlb-mips161.S:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST5/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/stdarg.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h ../../compile/ASST5/autoconf.h
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/spl.h ../../include/clock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../dev/lamebus/lamebus.h ../../include/cpu.h \
compile/ASST5/.depend:  opt-noasserts.h includelinks/platform/bus.h includelinks/machine/vm.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/sfs.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/spl.h ../../include/cpu.h \
compile/ASST5/.depend:  opt-noasserts.h
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/cdefs.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/test.h opt-synchprobs.h opt-sfs.h opt-net.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/threadlist.h \
compile/ASST5/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  opt-dumbvm.h
compile/ASST5/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/synch.h ../../include/spinlock.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/vm.h includelinks/machine/vm.h opt-dumbvm.h \
compile/ASST5/.depend:  ../../include/array.h ../../include/lib.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/array.h ../../include/test.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/bitmap.h ../../include/test.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/uio.h ../../include/kern/iovec.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  includelinks/machine/vm.h ../../include/test.h opt-dumbvm.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/clock.h ../../include/kern/time.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/kern/limits.h ../../include/test.h opt-synchprobs.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/cpu.h ../../include/spinlock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/addrspace.h ../../include/vm.h opt-dumbvm.h \
compile/ASST5/.depend:  ../../include/mainbus.h ../../include/vnode.h opt-synchprobs.h
compile/ASST5/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/uio.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/cdefs.h opt-noasserts.h ../../include/synch.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/vfs.h ../../include/array.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-dumbvm.h ../../include/proc.h ../../include/spinlock.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/spinlock.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/thread.h ../../include/array.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-noasserts.h ../../include/vm.h includelinks/machine/vm.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:  opt-dumbvm.h
compile/ASST5/.depend:adddi3.o: ../../../common/gcc-millicode/adddi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:anddi3.o: ../../../common/gcc-millicode/anddi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:ashldi3.o: ../../../common/gcc-millicode/ashldi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:ashrdi3.o: ../../../common/gcc-millicode/ashrdi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:cmpdi2.o: ../../../common/gcc-millicode/cmpdi2.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:divdi3.o: ../../../common/gcc-millicode/divdi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:iordi3.o: ../../../common/gcc-millicode/iordi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:lshldi3.o: ../../../common/gcc-millicode/lshldi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:lshrdi3.o: ../../../common/gcc-millicode/lshrdi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:moddi3.o: ../../../common/gcc-millicode/moddi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:muldi3.o: ../../../common/gcc-millicode/muldi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:negdi2.o: ../../../common/gcc-millicode/negdi2.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:notdi2.o: ../../../common/gcc-millicode/notdi2.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:qdivrem.o: ../../../common/gcc-millicode/qdivrem.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:subdi3.o: ../../../common/gcc-millicode/subdi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:ucmpdi2.o: ../../../common/gcc-millicode/ucmpdi2.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:udivdi3.o: ../../../common/gcc-millicode/udivdi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:umoddi3.o: ../../../common/gcc-millicode/umoddi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST5/.depend:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend:cache-mips161.o: ../../arch/mips/locore/cache-mips161.S \
compile/ASST5/.depend:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST5/.depend:tlb-mips161.o: ../../arch/mips/vm/tlb-mips161.S \
compile/ASST5/.depend:  opt-noasserts.h includelinks/mips/specialreg.h \
compile/ASST5/.depend.xordi3.c:xordi3.o: ../../../common/gcc-millicode/xordi3.c \
compile/ASST5/.depend.xordi3.c:  ../../../common/gcc-millicode/longlong.h ../../include/types.h \
compile/ASST5/.depend.copyinout.c:  ../../include/lib.h ../../include/cdefs.h opt-noasserts.h \
compile/ASST5/.depend.exception-mips1.S:exception-mips1.o: ../../arch/mips/locore/exception-mips1.S \
compile/ASST5/.depend.lamebus_machdep.c:  opt-noasserts.h includelinks/mips/specialreg.h \
conf/config:# Usage: ./config conf-name
conf/config:#    pseudoattach <dev>       define a pseudo-attachment for a device
conf/config:if [ ! -d ../dev ]; then
conf/config:    echo "Usage: $0 CONFIG-NAME"
conf/config:FOO=`echo $CONFNAME | tr -d 'a-zA-Z0-9_-'`
conf/config:if [ ! -f $CONFNAME ]; then
conf/config:rm -f $CONFTMP
conf/config:	# Directives that can be made machine-dependent with "machine"
conf/config:	    foundfields -= 2;
conf/config:	    foundfields -= 2;
conf/config:	    # special case - device directive can have 2 or 4 words
conf/config:	# Now actually process the directives we need at this stage - which
conf/config:    # There is only one - the one generated above with echo, which
conf/config:if [ ! -d "$COMPILEDIR" ]; then
conf/config:echo -n 'Generating files...'
conf/config:rm -f $CONFTMP.files
conf/config:rm -f $CONFTMP.attach
conf/config:	sub("^[a-zA-Z_]*", "", u);
conf/config:	    sub("[0-9]*", "", tmp);
conf/config:	sub("[\\*0-9]*$", "", base);
conf/config:	sub("[a-zA-Z_]*", "", tmp);
conf/config:	# - the former allows le0 to be at sbus1, allows le1, etc.
conf/config:	# Remember that this device is a pseudo-device.
conf/config:	    realfile = compiledir "/opt-" opt ".h";
conf/config:    for NF in opt-*.h.new; do
conf/config:	    rm -f $NF      # unchanged
conf/config:	    mv -f $NF $OF  # it changed
conf/config:	echo -n " $OF"
conf/config:# sufficient to compile them. However, some low-level kernel hacking
conf/config:	# For now a file cannot be both platform-dependent and
conf/config:	# machine-dependent, so this sequence of tests is enough.
conf/config:rm -f $CONFTMP.files
conf/config:echo -n ' files.mk'
conf/config:	BEGIN { debugflags="-O2"; }
conf/config:	    debugflags="-g";
conf/config:echo -n ' Makefile'
conf/config:# The autoconf_foo functions for attached devices are file-static
conf/config:awk < $CONFTMP.attach '$1=="noattach" { print $2 }' | sort -u | awk '
conf/config:    rm -f $ACH            # unchanged
conf/config:    mv -f $ACH $ACHREAL   # it changed
conf/config:echo -n ' autoconf.h'
conf/config:awk < $CONFTMP.attach '$1=="attach" || $1=="pseudo" { print $2 }' | sort -u |\
conf/config:awk < $CONFTMP.attach '$1=="attach" { print $2 }' | sort -u | awk '
conf/config:	printf "\t\treturn -1;\n";
conf/config:echo -n ' autoconf.c'
conf/config:rm -f $CONFTMP $CONFTMP.attach
conf/newvers.sh:# newvers.sh - increment build number in current directory (a build directory)
conf/newvers.sh:if [ ! -f autoconf.c ]; then
conf/conf.kern:# Machine-independent kernel config definitions.
conf/conf.kern:# "./config", not just "config" - in the latter case you will
conf/conf.kern:#       Additionally, a file "opt-optname.h" is created in the compile
conf/conf.kern:#            #include "opt-foo.h"
conf/conf.kern:#       *** Be sure to use #if and not #ifdef - you want the value
conf/conf.kern:#           option - if you don't, cpp will silently assume it is 0,
conf/conf.kern:#       system main bus which is located in a machine-dependent way.
conf/conf.kern:#       Software-only devices are known as "pseudo-devices". These
conf/conf.kern:#       and ISA cards - the chipset behaves the same way in both
conf/conf.kern:#       in the kernel. A top-level device with no attachments should
conf/conf.kern:#       A pseudo-device should be included with this syntax:
conf/conf.kern:# Generic machine-independent devices. #
conf/conf.kern:#        Machine-dependent stuff       #
conf/conf.kern:# contents of the top-level defs.mk file.
conf/conf.kern:# This will declare a bunch of machine-dependent source files and also
conf/conf.kern:# expect to find is machine-dependent.)
conf/conf.kern:# netfs (the networked filesystem - you might write this as one assignment)
dev/generic/beep.c: * Machine-independent generic beep "device".
dev/generic/beep.c:		the_beep->bs_beep(the_beep->bs_devdata);
dev/generic/beep.h: * The device info for the generic MI beep device - a function
dev/generic/console.c:	cs->cs_sendpolled(cs->cs_devdata, ch);
dev/generic/console.c:	P(cs->cs_wsem);
dev/generic/console.c:	cs->cs_send(cs->cs_devdata, ch);
dev/generic/console.c:	P(cs->cs_rsem);
dev/generic/console.c:	ret = cs->cs_gotchars[cs->cs_gotchars_tail];
dev/generic/console.c:	cs->cs_gotchars_tail =
dev/generic/console.c:		(cs->cs_gotchars_tail + 1) % CONSOLE_INPUT_BUFFER_SIZE;
dev/generic/console.c: * Called from underlying device when a read-ready interrupt occurs.
dev/generic/console.c:	nexthead = (cs->cs_gotchars_head + 1) % CONSOLE_INPUT_BUFFER_SIZE;
dev/generic/console.c:	if (nexthead == cs->cs_gotchars_tail) {
dev/generic/console.c:	cs->cs_gotchars[cs->cs_gotchars_head] = ch;
dev/generic/console.c:	cs->cs_gotchars_head = nexthead;
dev/generic/console.c:	V(cs->cs_rsem);
dev/generic/console.c: * Called from underlying device when a write-done interrupt occurs.
dev/generic/console.c:	V(cs->cs_wsem);
dev/generic/console.c:	else if (curthread->t_in_interrupt ||
dev/generic/console.c:		 curthread->t_curspl > 0 ||
dev/generic/console.c:		 curcpu->c_spinlocks > 0) {
dev/generic/console.c:	KASSERT(!curthread->t_in_interrupt && curthread->t_iplhigh_count == 0);
dev/generic/console.c:	if (uio->uio_rw==UIO_READ) {
dev/generic/console.c:	while (uio->uio_resid > 0) {
dev/generic/console.c:		if (uio->uio_rw==UIO_READ) {
dev/generic/console.c:	dev->d_ops = &console_devops;
dev/generic/console.c:	dev->d_blocks = 0;
dev/generic/console.c:	dev->d_blocksize = 1;
dev/generic/console.c:	dev->d_data = cs;
dev/generic/console.c:	rlk = lock_create("console-lock-read");
dev/generic/console.c:	wlk = lock_create("console-lock-write");
dev/generic/console.c:	cs->cs_rsem = rsem;
dev/generic/console.c:	cs->cs_wsem = wsem;
dev/generic/console.c:	cs->cs_gotchars_head = 0;
dev/generic/console.c:	cs->cs_gotchars_tail = 0;
dev/generic/console.h: * Device data for the hardware-independent system console.
dev/generic/console.h: * Functions called by lower-level drivers
dev/generic/console.h: * Functions called by higher-level code
dev/generic/console.h: * putch/getch - see <lib.h>
dev/generic/random.c: * Machine-independent generic randomness device.
dev/generic/random.c:	struct random_softc *rs = dev->d_data;
dev/generic/random.c:	if (uio->uio_rw != UIO_READ) {
dev/generic/random.c:	return rs->rs_read(rs->rs_devdata, uio);
dev/generic/random.c:	rs->rs_dev.d_ops = &random_devops;
dev/generic/random.c:	rs->rs_dev.d_blocks = 0;
dev/generic/random.c:	rs->rs_dev.d_blocksize = 1;
dev/generic/random.c:	rs->rs_dev.d_data = rs;
dev/generic/random.c:	result = vfs_adddev("random", &rs->rs_dev, 0);
dev/generic/random.c:	return the_random->rs_random(the_random->rs_devdata);
dev/generic/random.c:	return the_random->rs_randmax(the_random->rs_devdata);
dev/generic/random.h:	/* Initialized by lower-level attach routine */
dev/generic/rtclock.c: * Machine-independent generic clock "device".
dev/generic/rtclock.c:	the_clock->rtc_gettime(the_clock->rtc_devdata, ts);
dev/generic/rtclock.h: * The device info for the generic MI clock device - a function
dev/lamebus/beep_ltimer.c:	bs->bs_devdata = ls;
dev/lamebus/beep_ltimer.c:	bs->bs_beep = ltimer_beep;
dev/lamebus/con_lscreen.c:	cs->cs_devdata = ls;
dev/lamebus/con_lscreen.c:	cs->cs_send = lscreen_write;
dev/lamebus/con_lscreen.c:	cs->cs_sendpolled = lscreen_write;
dev/lamebus/con_lscreen.c:	ls->ls_devdata = cs;
dev/lamebus/con_lscreen.c:	ls->ls_start = con_start;
dev/lamebus/con_lscreen.c:	ls->ls_input = con_input;
dev/lamebus/con_lser.c:	cs->cs_devdata = ls;
dev/lamebus/con_lser.c:	cs->cs_send = lser_write;
dev/lamebus/con_lser.c:	cs->cs_sendpolled = lser_writepolled;
dev/lamebus/con_lser.c:	ls->ls_devdata = cs;
dev/lamebus/con_lser.c:	ls->ls_start = con_start;
dev/lamebus/con_lser.c:	ls->ls_input = con_input;
dev/lamebus/emu.c:	return bus_read_register(sc->e_busdata, sc->e_buspos, reg);
dev/lamebus/emu.c:	bus_write_register(sc->e_busdata, sc->e_buspos, reg, val);
dev/lamebus/emu.c:	sc->e_result = emu_rreg(sc, REG_RESULT);
dev/lamebus/emu.c:	V(sc->e_sem);
dev/lamebus/emu.c:		panic("emu%d: got fatal result code %d\n", sc->e_unit, code);
dev/lamebus/emu.c:	kprintf("emu%d: Unknown result code %d\n", sc->e_unit, code);
dev/lamebus/emu.c:	P(sc->e_sem);
dev/lamebus/emu.c:	return translate_err(sc, sc->e_result);
dev/lamebus/emu.c:	lock_acquire(sc->e_lock);
dev/lamebus/emu.c:	strcpy(sc->e_iobuf, name);
dev/lamebus/emu.c:	lock_release(sc->e_lock);
dev/lamebus/emu.c:	mine = lock_do_i_hold(sc->e_lock);
dev/lamebus/emu.c:		lock_acquire(sc->e_lock);
dev/lamebus/emu.c:				sc->e_unit);
dev/lamebus/emu.c:		lock_release(sc->e_lock);
dev/lamebus/emu.c:	KASSERT(uio->uio_rw == UIO_READ);
dev/lamebus/emu.c:	if (uio->uio_offset > (off_t)0xffffffff) {
dev/lamebus/emu.c:	lock_acquire(sc->e_lock);
dev/lamebus/emu.c:	emu_wreg(sc, REG_OFFSET, uio->uio_offset);
dev/lamebus/emu.c:	result = uiomove(sc->e_iobuf, emu_rreg(sc, REG_IOLEN), uio);
dev/lamebus/emu.c:	uio->uio_offset = emu_rreg(sc, REG_OFFSET);
dev/lamebus/emu.c:	lock_release(sc->e_lock);
dev/lamebus/emu.c: * Read from a hardware-level file handle.
dev/lamebus/emu.c: * Read a directory entry from a hardware-level file handle.
dev/lamebus/emu.c: * Write to a hardware-level file handle.
dev/lamebus/emu.c:	KASSERT(uio->uio_rw == UIO_WRITE);
dev/lamebus/emu.c:	if (uio->uio_offset > (off_t)0xffffffff) {
dev/lamebus/emu.c:	lock_acquire(sc->e_lock);
dev/lamebus/emu.c:	emu_wreg(sc, REG_OFFSET, uio->uio_offset);
dev/lamebus/emu.c:	result = uiomove(sc->e_iobuf, len, uio);
dev/lamebus/emu.c:	lock_release(sc->e_lock);
dev/lamebus/emu.c: * Get the file size associated with a hardware-level file handle.
dev/lamebus/emu.c:	lock_acquire(sc->e_lock);
dev/lamebus/emu.c:	lock_release(sc->e_lock);
dev/lamebus/emu.c: * Truncate a hardware-level file handle.
dev/lamebus/emu.c:	lock_acquire(sc->e_lock);
dev/lamebus/emu.c:	lock_release(sc->e_lock);
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	struct emufs_fs *ef = v->vn_fs->fs_data;
dev/lamebus/emu.c:	 * vfs_biglock to protect the fs-related material, and
dev/lamebus/emu.c:	lock_acquire(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	spinlock_acquire(&ev->ev_v.vn_countlock);
dev/lamebus/emu.c:	if (ev->ev_v.vn_refcount > 1) {
dev/lamebus/emu.c:		ev->ev_v.vn_refcount--;
dev/lamebus/emu.c:		spinlock_release(&ev->ev_v.vn_countlock);
dev/lamebus/emu.c:		lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	KASSERT(ev->ev_v.vn_refcount == 1);
dev/lamebus/emu.c:	spinlock_release(&ev->ev_v.vn_countlock);
dev/lamebus/emu.c:	result = emu_close(ev->ev_emu, ev->ev_handle);
dev/lamebus/emu.c:		lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	num = vnodearray_num(ef->ef_vnodes);
dev/lamebus/emu.c:		vx = vnodearray_get(ef->ef_vnodes, i);
dev/lamebus/emu.c:		      ef->ef_emu->e_unit, ev->ev_handle);
dev/lamebus/emu.c:	vnodearray_remove(ef->ef_vnodes, ix);
dev/lamebus/emu.c:	vnode_cleanup(&ev->ev_v);
dev/lamebus/emu.c:	lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	KASSERT(uio->uio_rw==UIO_READ);
dev/lamebus/emu.c:	while (uio->uio_resid > 0) {
dev/lamebus/emu.c:		amt = uio->uio_resid;
dev/lamebus/emu.c:		oldresid = uio->uio_resid;
dev/lamebus/emu.c:		result = emu_read(ev->ev_emu, ev->ev_handle, amt, uio);
dev/lamebus/emu.c:		if (uio->uio_resid == oldresid) {
dev/lamebus/emu.c:			/* nothing read - EOF */
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	KASSERT(uio->uio_rw==UIO_READ);
dev/lamebus/emu.c:	amt = uio->uio_resid;
dev/lamebus/emu.c:	return emu_readdir(ev->ev_emu, ev->ev_handle, amt, uio);
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	KASSERT(uio->uio_rw==UIO_WRITE);
dev/lamebus/emu.c:	while (uio->uio_resid > 0) {
dev/lamebus/emu.c:		amt = uio->uio_resid;
dev/lamebus/emu.c:		oldresid = uio->uio_resid;
dev/lamebus/emu.c:		result = emu_write(ev->ev_emu, ev->ev_handle, amt, uio);
dev/lamebus/emu.c:		if (uio->uio_resid == oldresid) {
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	result = emu_getsize(ev->ev_emu, ev->ev_handle, &statbuf->st_size);
dev/lamebus/emu.c:	result = VOP_GETTYPE(v, &statbuf->st_mode);
dev/lamebus/emu.c:	statbuf->st_mode |= 0644; /* possibly a lie */
dev/lamebus/emu.c:	statbuf->st_nlink = 1;    /* might be a lie, but doesn't matter much */
dev/lamebus/emu.c:	statbuf->st_blocks = 0;   /* almost certainly a lie */
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	return emu_trunc(ev->ev_emu, ev->ev_handle, len);
dev/lamebus/emu.c:	struct emufs_vnode *ev = dir->vn_data;
dev/lamebus/emu.c:	struct emufs_fs *ef = dir->vn_fs->fs_data;
dev/lamebus/emu.c:	result = emu_open(ev->ev_emu, ev->ev_handle, name, true, excl, mode,
dev/lamebus/emu.c:		emu_close(ev->ev_emu, handle);
dev/lamebus/emu.c:	*ret = &newguy->ev_v;
dev/lamebus/emu.c:	struct emufs_vnode *ev = dir->vn_data;
dev/lamebus/emu.c:	struct emufs_fs *ef = dir->vn_fs->fs_data;
dev/lamebus/emu.c:	result = emu_open(ev->ev_emu, ev->ev_handle, pathname, false, false, 0,
dev/lamebus/emu.c:		emu_close(ev->ev_emu, handle);
dev/lamebus/emu.c:	*ret = &newguy->ev_v;
dev/lamebus/emu.c:	struct emufs_vnode *ev = v->vn_data;
dev/lamebus/emu.c:	struct emufs_fs *ef = v->vn_fs->fs_data;
dev/lamebus/emu.c:	if (ev == ef->ef_root) {
dev/lamebus/emu.c:		 * Root directory - name is empty string
dev/lamebus/emu.c: * pointer that's cast to a op-specific args structure) avoids this
dev/lamebus/emu.c:	lock_acquire(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	num = vnodearray_num(ef->ef_vnodes);
dev/lamebus/emu.c:		v = vnodearray_get(ef->ef_vnodes, i);
dev/lamebus/emu.c:		ev = v->vn_data;
dev/lamebus/emu.c:		if (ev->ev_handle == handle) {
dev/lamebus/emu.c:			VOP_INCREF(&ev->ev_v);
dev/lamebus/emu.c:			lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:		lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	ev->ev_emu = ef->ef_emu;
dev/lamebus/emu.c:	ev->ev_handle = handle;
dev/lamebus/emu.c:	result = vnode_init(&ev->ev_v, isdir ? &emufs_dirops : &emufs_fileops,
dev/lamebus/emu.c:			    &ef->ef_fs, ev);
dev/lamebus/emu.c:		lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	result = vnodearray_add(ef->ef_vnodes, &ev->ev_v, NULL);
dev/lamebus/emu.c:		/* note: vnode_cleanup undoes vnode_init - it does not kfree */
dev/lamebus/emu.c:		vnode_cleanup(&ev->ev_v);
dev/lamebus/emu.c:		lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:	lock_release(ef->ef_emu->e_lock);
dev/lamebus/emu.c:// Whole-filesystem functions
dev/lamebus/emu.c:	ef = fs->fs_data;
dev/lamebus/emu.c:	KASSERT(ef->ef_root != NULL);
dev/lamebus/emu.c:	VOP_INCREF(&ef->ef_root->ev_v);
dev/lamebus/emu.c:	*ret = &ef->ef_root->ev_v;
dev/lamebus/emu.c: * Routine for "mounting" an emufs - we're not really mounted in the
dev/lamebus/emu.c:	ef->ef_fs.fs_data = ef;
dev/lamebus/emu.c:	ef->ef_fs.fs_ops = &emufs_fsops;
dev/lamebus/emu.c:	ef->ef_emu = sc;
dev/lamebus/emu.c:	ef->ef_root = NULL;
dev/lamebus/emu.c:	ef->ef_vnodes = vnodearray_create();
dev/lamebus/emu.c:	if (ef->ef_vnodes == NULL) {
dev/lamebus/emu.c:	result = emufs_loadvnode(ef, EMU_ROOTHANDLE, 1, &ef->ef_root);
dev/lamebus/emu.c:	KASSERT(ef->ef_root!=NULL);
dev/lamebus/emu.c:	result = vfs_addfs(devname, &ef->ef_fs);
dev/lamebus/emu.c:		VOP_DECREF(&ef->ef_root->ev_v);
dev/lamebus/emu.c:	sc->e_lock = lock_create("emufs-lock");
dev/lamebus/emu.c:	if (sc->e_lock == NULL) {
dev/lamebus/emu.c:	sc->e_sem = sem_create("emufs-sem", 0);
dev/lamebus/emu.c:	if (sc->e_sem == NULL) {
dev/lamebus/emu.c:		lock_destroy(sc->e_lock);
dev/lamebus/emu.c:		sc->e_lock = NULL;
dev/lamebus/emu.c:	sc->e_iobuf = bus_map_area(sc->e_busdata, sc->e_buspos, EMU_BUFFER);
dev/lamebus/emu.h: * The per-device data used by the emufs device driver.
dev/lamebus/emu.h:	/* Initialized by lower-level attach code */
dev/lamebus/emu.h:/* Functions called by lower-level drivers */
dev/lamebus/emu_att.c:	es->e_busdata = sc;
dev/lamebus/emu_att.c:	es->e_buspos = slot;
dev/lamebus/emu_att.c:	es->e_unit = emuno;
dev/lamebus/lamebus.c: * Machine-independent LAMEbus code.
dev/lamebus/lamebus.c:/* LAMEbus CPU control registers (offsets within each per-cpu region) */
dev/lamebus/lamebus.c:		lamebus->ls_uniprocessor = 1;
dev/lamebus/lamebus.c:				curcpu->c_hardware_number = i;
dev/lamebus/lamebus.c: * here assumes the boot CPU is CPU 0 and the others are 1-N as
dev/lamebus/lamebus.c:	if (lamebus->ls_uniprocessor) {
dev/lamebus/lamebus.c: * Returns the slot number found (0-31) or -1 if nothing suitable was
dev/lamebus/lamebus.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lamebus.c:		if (sc->ls_slotsinuse & (1<<slot)) {
dev/lamebus/lamebus.c:		spinlock_release(&sc->ls_lock);
dev/lamebus/lamebus.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lamebus.c:	return -1;
dev/lamebus/lamebus.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lamebus.c:	if ((sc->ls_slotsinuse & mask)!=0) {
dev/lamebus/lamebus.c:	sc->ls_slotsinuse |= mask;
dev/lamebus/lamebus.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lamebus.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lamebus.c:	if ((sc->ls_slotsinuse & mask)==0) {
dev/lamebus/lamebus.c:	sc->ls_slotsinuse &= ~mask;
dev/lamebus/lamebus.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lamebus.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lamebus.c:	if ((sc->ls_slotsinuse & mask)==0) {
dev/lamebus/lamebus.c:	KASSERT(sc->ls_devdata[slot]==NULL);
dev/lamebus/lamebus.c:	KASSERT(sc->ls_irqfuncs[slot]==NULL);
dev/lamebus/lamebus.c:	sc->ls_devdata[slot] = devdata;
dev/lamebus/lamebus.c:	sc->ls_irqfuncs[slot] = irqfunc;
dev/lamebus/lamebus.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lamebus.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lamebus.c:	if ((sc->ls_slotsinuse & mask)==0) {
dev/lamebus/lamebus.c:	KASSERT(sc->ls_irqfuncs[slot]!=NULL);
dev/lamebus/lamebus.c:	sc->ls_devdata[slot] = NULL;
dev/lamebus/lamebus.c:	sc->ls_irqfuncs[slot] = NULL;
dev/lamebus/lamebus.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lamebus.c:	spinlock_acquire(&lamebus->ls_lock);
dev/lamebus/lamebus.c:	spinlock_release(&lamebus->ls_lock);
dev/lamebus/lamebus.c:	spinlock_acquire(&lamebus->ls_lock);
dev/lamebus/lamebus.c:	spinlock_release(&lamebus->ls_lock);
dev/lamebus/lamebus.c: * LAMEbus interrupt handling function. (Machine-independent!)
dev/lamebus/lamebus.c:	 * Note that the entire LAMEbus uses only one on-cpu interrupt line.
dev/lamebus/lamebus.c:	 * Thus, we do not use any on-cpu interrupt priority system either.
dev/lamebus/lamebus.c:	spinlock_acquire(&lamebus->ls_lock);
dev/lamebus/lamebus.c:			curcpu->c_number);
dev/lamebus/lamebus.c:		if ((lamebus->ls_slotsinuse & mask)==0) {
dev/lamebus/lamebus.c:		if (lamebus->ls_irqfuncs[slot]==NULL) {
dev/lamebus/lamebus.c:		handler = lamebus->ls_irqfuncs[slot];
dev/lamebus/lamebus.c:		data = lamebus->ls_devdata[slot];
dev/lamebus/lamebus.c:		spinlock_release(&lamebus->ls_lock);
dev/lamebus/lamebus.c:		spinlock_acquire(&lamebus->ls_lock);
dev/lamebus/lamebus.c:		 * Reload the mask of pending IRQs - if we just called
dev/lamebus/lamebus.c:	 * uses level-triggered interrupts, if we don't shut off the
dev/lamebus/lamebus.c:	spinlock_release(&lamebus->ls_lock);
dev/lamebus/lamebus.c:	if (lamebus->ls_uniprocessor) {
dev/lamebus/lamebus.c:	write_ctlcpu_register(lamebus, target->c_hardware_number,
dev/lamebus/lamebus.c:	if (lamebus->ls_uniprocessor) {
dev/lamebus/lamebus.c:	write_ctlcpu_register(lamebus, target->c_hardware_number,
dev/lamebus/lamebus.c:	spinlock_init(&lamebus->ls_lock);
dev/lamebus/lamebus.c:	lamebus->ls_slotsinuse = 1 << LB_CONTROLLER_SLOT;
dev/lamebus/lamebus.c:		lamebus->ls_devdata[i] = NULL;
dev/lamebus/lamebus.c:		lamebus->ls_irqfuncs[i] = NULL;
dev/lamebus/lamebus.c:	lamebus->ls_uniprocessor = 0;
dev/lamebus/lamebus.h: * Machine-independent definitions.
dev/lamebus/lamebus.h:/* LAMEbus controller per-slot config space */
dev/lamebus/lamebus.h:/* LAMEbus controller per-cpu control space */
dev/lamebus/lamebus.h:/* LAMEbus controller slot offset to per-cpu control space */
dev/lamebus/lamebus.h:	/* Read-only once set early in boot */
dev/lamebus/lamebus.h: * Look for a not-in-use slot containing a device whose vendor and device
dev/lamebus/lamebus.h: * Returns a slot number (0-31) or -1 if no such device is found.
dev/lamebus/lamebus.h: * Mark a slot in-use (that is, has a device driver attached to it),
dev/lamebus/lamebus.h: * Turn on or off the inter-processor interrupt line to a CPU.
dev/lamebus/lamebus.h: * Read/write 32-bit register at offset OFFSET within slot SLOT.
dev/lamebus/lhd.c:	return bus_read_register(lh->lh_busdata, lh->lh_buspos, reg);
dev/lamebus/lhd.c:	bus_write_register(lh->lh_busdata, lh->lh_buspos, reg, val);
dev/lamebus/lhd.c:	kprintf("lhd%d: Unknown result code %d\n", lh->lh_unit, code);
dev/lamebus/lhd.c:	lh->lh_result = err;
dev/lamebus/lhd.c:	V(lh->lh_done);
dev/lamebus/lhd.c:	struct lhd_softc *lh = d->d_data;
dev/lamebus/lhd.c:	uint32_t sector = uio->uio_offset / LHD_SECTSIZE;
dev/lamebus/lhd.c:	uint32_t sectoff = uio->uio_offset % LHD_SECTSIZE;
dev/lamebus/lhd.c:	uint32_t len = uio->uio_resid / LHD_SECTSIZE;
dev/lamebus/lhd.c:	uint32_t lenoff = uio->uio_resid % LHD_SECTSIZE;
dev/lamebus/lhd.c:	/* Don't allow I/O that isn't sector-aligned. */
dev/lamebus/lhd.c:	if (sector+len > lh->lh_dev.d_blocks) {
dev/lamebus/lhd.c:	if (uio->uio_rw==UIO_WRITE) {
dev/lamebus/lhd.c:		P(lh->lh_clear);
dev/lamebus/lhd.c:		 * on-card buffer.
dev/lamebus/lhd.c:		if (uio->uio_rw == UIO_WRITE) {
dev/lamebus/lhd.c:			result = uiomove(lh->lh_buf, LHD_SECTSIZE, uio);
dev/lamebus/lhd.c:				V(lh->lh_clear);
dev/lamebus/lhd.c:		P(lh->lh_done);
dev/lamebus/lhd.c:		result = lh->lh_result;
dev/lamebus/lhd.c:		 * transfer the data out of the on-card buffer.
dev/lamebus/lhd.c:		if (result==0 && uio->uio_rw==UIO_READ) {
dev/lamebus/lhd.c:			result = uiomove(lh->lh_buf, LHD_SECTSIZE, uio);
dev/lamebus/lhd.c:		V(lh->lh_clear);
dev/lamebus/lhd.c:	/* Get a pointer to the on-chip buffer. */
dev/lamebus/lhd.c:	lh->lh_buf = bus_map_area(lh->lh_busdata, lh->lh_buspos, LHD_BUFFER);
dev/lamebus/lhd.c:	lh->lh_clear = sem_create("lhd-clear", 1);
dev/lamebus/lhd.c:	if (lh->lh_clear == NULL) {
dev/lamebus/lhd.c:	lh->lh_done = sem_create("lhd-done", 0);
dev/lamebus/lhd.c:	if (lh->lh_done == NULL) {
dev/lamebus/lhd.c:		sem_destroy(lh->lh_clear);
dev/lamebus/lhd.c:		lh->lh_clear = NULL;
dev/lamebus/lhd.c:	lh->lh_dev.d_ops = &lhd_devops;
dev/lamebus/lhd.c:	lh->lh_dev.d_blocks = bus_read_register(lh->lh_busdata, lh->lh_buspos,
dev/lamebus/lhd.c:	lh->lh_dev.d_blocksize = LHD_SECTSIZE;
dev/lamebus/lhd.c:	lh->lh_dev.d_data = lh;
dev/lamebus/lhd.c:	return vfs_adddev(name, &lh->lh_dev, 1);
dev/lamebus/lhd.h:	/* Initialized by lower-level attach code */
dev/lamebus/lhd.h:	void *lh_buf;			/* Pointer to on-card I/O buffer */
dev/lamebus/lhd.h:/* Functions called by lower-level drivers */
dev/lamebus/lhd_att.c:	lh->lh_busdata = sc;
dev/lamebus/lhd_att.c:	lh->lh_buspos = slot;
dev/lamebus/lhd_att.c:	lh->lh_unit = lhdno;
dev/lamebus/lrandom.c:	return bus_read_register(lr->lr_bus, lr->lr_buspos, LR_REG_RAND);
dev/lamebus/lrandom.c:	while (uio->uio_resid > 0) {
dev/lamebus/lrandom.c:		val = bus_read_register(lr->lr_bus, lr->lr_buspos,
dev/lamebus/lrandom.h:	/* Initialized by lower-level attach routine */
dev/lamebus/lrandom.h:/* Functions called by higher-level drivers */
dev/lamebus/lrandom_att.c:	lr->lr_bus = sc;
dev/lamebus/lrandom_att.c:	lr->lr_buspos = slot;
dev/lamebus/lscreen.c: * Driver for full-screen console.
dev/lamebus/lscreen.c: * As of this writing the full-screen console is not supported in
dev/lamebus/lscreen.c:/* Convert a 32-bit X/Y pair to X and Y coordinates. */
dev/lamebus/lscreen.c:/* Convert X and Y coordinates to a single 32-bit value. */
dev/lamebus/lscreen.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lscreen.c:	x = bus_read_register(sc->ls_busdata, sc->ls_buspos, LSCR_REG_RIRQ);
dev/lamebus/lscreen.c:		ch = bus_read_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.c:		bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.c:		spinlock_release(&sc->ls_lock);
dev/lamebus/lscreen.c:		if (sc->ls_input) {
dev/lamebus/lscreen.c:			sc->ls_input(sc->ls_devdata, ch);
dev/lamebus/lscreen.c:		spinlock_release(&sc->ls_lock);
dev/lamebus/lscreen.c:	if (sc->ls_cy >= sc->ls_height-1) {
dev/lamebus/lscreen.c:		memmove(sc->ls_screen, sc->ls_screen + sc->ls_width,
dev/lamebus/lscreen.c:			sc->ls_width * (sc->ls_height-1));
dev/lamebus/lscreen.c:		bzero(sc->ls_screen + sc->ls_width * (sc->ls_height-1),
dev/lamebus/lscreen.c:		      sc->ls_width);
dev/lamebus/lscreen.c:		sc->ls_cy++;
dev/lamebus/lscreen.c:	sc->ls_cx=0;
dev/lamebus/lscreen.c:	if (sc->ls_cx >= sc->ls_width) {
dev/lamebus/lscreen.c:	sc->ls_screen[sc->ls_cy*sc->ls_width + sc->ls_cx] = ch;
dev/lamebus/lscreen.c:	sc->ls_cx++;
dev/lamebus/lscreen.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lscreen.c:	ccx = sc->ls_cx;
dev/lamebus/lscreen.c:	ccy = sc->ls_cy;
dev/lamebus/lscreen.c:	if (ccx==sc->ls_width) {
dev/lamebus/lscreen.c:		ccx--;
dev/lamebus/lscreen.c:	bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lscreen.c:	spinlock_init(&sc->ls_lock);
dev/lamebus/lscreen.c:	bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.c:	val = bus_read_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.c:	splitxy(val, &sc->ls_width, &sc->ls_height);
dev/lamebus/lscreen.c:	val = bus_read_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.c:	splitxy(val, &sc->ls_cx, &sc->ls_cy);
dev/lamebus/lscreen.c:	 * Get a pointer to the memory-mapped screen area.
dev/lamebus/lscreen.c:	sc->ls_screen = bus_map_area(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lscreen.h: * Hardware device data for memory-mapped fullscreen text console.
dev/lamebus/lscreen.h:	char *ls_screen;              // memory-mapped screen buffer
dev/lamebus/lscreen.h:	/* Initialized by lower-level attachment function */
dev/lamebus/lscreen.h:	/* Initialized by higher-level attachment function */
dev/lamebus/lscreen.h:/* Functions called by lower-level drivers */
dev/lamebus/lscreen.h:/* Functions called by higher-level drivers */
dev/lamebus/lscreen_att.c:	ls->ls_busdata = sc;
dev/lamebus/lscreen_att.c:	ls->ls_buspos = slot;
dev/lamebus/lser.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lser.c:	x = bus_read_register(sc->ls_busdata, sc->ls_buspos, LSER_REG_WIRQ);
dev/lamebus/lser.c:		sc->ls_wbusy = 0;
dev/lamebus/lser.c:		bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:	x = bus_read_register(sc->ls_busdata, sc->ls_buspos, LSER_REG_RIRQ);
dev/lamebus/lser.c:		ch = bus_read_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:		bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lser.c:	if (clear_to_write && sc->ls_start != NULL) {
dev/lamebus/lser.c:		sc->ls_start(sc->ls_devdata);
dev/lamebus/lser.c:	if (got_a_read && sc->ls_input != NULL) {
dev/lamebus/lser.c:		sc->ls_input(sc->ls_devdata, ch);
dev/lamebus/lser.c:	spinlock_acquire(&ls->ls_lock);
dev/lamebus/lser.c:	if (ls->ls_wbusy) {
dev/lamebus/lser.c:		 * ls->ls_start.
dev/lamebus/lser.c:	ls->ls_wbusy = true;
dev/lamebus/lser.c:	bus_write_register(ls->ls_busdata, ls->ls_buspos, LSER_REG_CHAR, ch);
dev/lamebus/lser.c:	spinlock_release(&ls->ls_lock);
dev/lamebus/lser.c:	KASSERT(spinlock_do_i_hold(&sc->ls_lock));
dev/lamebus/lser.c:		val = bus_read_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:	spinlock_acquire(&sc->ls_lock);
dev/lamebus/lser.c:	if (sc->ls_wbusy) {
dev/lamebus/lser.c:		bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:		bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:	bus_write_register(sc->ls_busdata, sc->ls_buspos, LSER_REG_CHAR, ch);
dev/lamebus/lser.c:		bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:	spinlock_release(&sc->ls_lock);
dev/lamebus/lser.c:	spinlock_init(&sc->ls_lock);
dev/lamebus/lser.c:	sc->ls_wbusy = false;
dev/lamebus/lser.c:	bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.c:	bus_write_register(sc->ls_busdata, sc->ls_buspos,
dev/lamebus/lser.h:	/* Initialized by lower-level attachment function */
dev/lamebus/lser.h:	/* Initialized by higher-level attachment function */
dev/lamebus/lser.h:/* Functions called by lower-level drivers */
dev/lamebus/lser.h:/* Functions called by higher-level drivers */
dev/lamebus/lser_att.c:	ls->ls_busdata = sc;
dev/lamebus/lser_att.c:	ls->ls_buspos = slot;
dev/lamebus/ltimer.c:#define LT_REG_ROE    8     /* Restart On countdown-timer Expiry flag */
dev/lamebus/ltimer.c:	 * on-chip timer for hardclock and we don't need ltimer as
dev/lamebus/ltimer.c:	 * that LAMEbus uses level-triggered interrupts, so the
dev/lamebus/ltimer.c:	lt->lt_hardclock = 0;
dev/lamebus/ltimer.c:	 * on-chip timer can't do that.
dev/lamebus/ltimer.c:		lt->lt_timerclock = 1;
dev/lamebus/ltimer.c:		bus_write_register(lt->lt_bus, lt->lt_buspos, LT_REG_ROE, 1);
dev/lamebus/ltimer.c:		bus_write_register(lt->lt_bus, lt->lt_buspos, LT_REG_COUNT,
dev/lamebus/ltimer.c:	val = bus_read_register(lt->lt_bus, lt->lt_buspos, LT_REG_IRQ);
dev/lamebus/ltimer.c:		if (lt->lt_hardclock) {
dev/lamebus/ltimer.c:		if (lt->lt_timerclock) {
dev/lamebus/ltimer.c:	bus_write_register(lt->lt_bus, lt->lt_buspos, LT_REG_SPKR, 440);
dev/lamebus/ltimer.c:	secs1 = bus_read_register(lt->lt_bus, lt->lt_buspos,
dev/lamebus/ltimer.c:	ts->tv_nsec = bus_read_register(lt->lt_bus, lt->lt_buspos,
dev/lamebus/ltimer.c:	secs2 = bus_read_register(lt->lt_bus, lt->lt_buspos,
dev/lamebus/ltimer.c:	if (ts->tv_nsec < 5000000) {
dev/lamebus/ltimer.c:		ts->tv_sec = secs2;
dev/lamebus/ltimer.c:		ts->tv_sec = secs1;
dev/lamebus/ltimer.h:	/* Initialized by lower-level attach routine */
dev/lamebus/ltimer.h:/* Functions called by lower-level drivers */
dev/lamebus/ltimer.h:/* Functions called by higher-level devices */
dev/lamebus/ltimer_att.c:	lt->lt_bus = sc;
dev/lamebus/ltimer_att.c:	lt->lt_buspos = slot;
dev/lamebus/ltrace.c:		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
dev/lamebus/ltrace.c:		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
dev/lamebus/ltrace.c:		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
dev/lamebus/ltrace.c:		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
dev/lamebus/ltrace.c:	if (the_trace != NULL && the_trace->lt_canstop) {
dev/lamebus/ltrace.c:		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
dev/lamebus/ltrace.h:	/* Initialized by lower-level attachment function */
dev/lamebus/ltrace_att.c:	lt->lt_busdata = sc;
dev/lamebus/ltrace_att.c:	lt->lt_buspos = slot;
dev/lamebus/ltrace_att.c:	lt->lt_canstop = drl >= STOP_VERSION;
dev/lamebus/random_lrandom.c:	rs->rs_devdata = ls;
dev/lamebus/random_lrandom.c:	rs->rs_random = lrandom_random;
dev/lamebus/random_lrandom.c:	rs->rs_randmax = lrandom_randmax;
dev/lamebus/random_lrandom.c:	rs->rs_read = lrandom_read;
dev/lamebus/rtclock_ltimer.c:	rtc->rtc_devdata = ls;
dev/lamebus/rtclock_ltimer.c:	rtc->rtc_gettime = ltimer_gettime;
fs/semfs/semfs.h: * A user-facing semaphore.
fs/semfs/semfs.h: * We don't use the kernel-level semaphore to implement it (although
fs/semfs/semfs.h:	struct semfs *semv_semfs;		/* Back-pointer to fs */
fs/semfs/semfs_fsops.c:// fs-level operations
fs/semfs/semfs_fsops.c:	struct semfs *semfs = fs->fs_data;
fs/semfs/semfs_fsops.c:	num = semfs_semarray_num(semfs->semfs_sems);
fs/semfs/semfs_fsops.c:		sem = semfs_semarray_get(semfs->semfs_sems, i);
fs/semfs/semfs_fsops.c:	semfs_semarray_setsize(semfs->semfs_sems, 0);
fs/semfs/semfs_fsops.c:	num = semfs_direntryarray_num(semfs->semfs_dents);
fs/semfs/semfs_fsops.c:		dent = semfs_direntryarray_get(semfs->semfs_dents, i);
fs/semfs/semfs_fsops.c:	semfs_direntryarray_setsize(semfs->semfs_dents, 0);
fs/semfs/semfs_fsops.c:	semfs_direntryarray_destroy(semfs->semfs_dents);
fs/semfs/semfs_fsops.c:	lock_destroy(semfs->semfs_dirlock);
fs/semfs/semfs_fsops.c:	semfs_semarray_destroy(semfs->semfs_sems);
fs/semfs/semfs_fsops.c:	vnodearray_destroy(semfs->semfs_vnodes);
fs/semfs/semfs_fsops.c:	lock_destroy(semfs->semfs_tablelock);
fs/semfs/semfs_fsops.c:	struct semfs *semfs = fs->fs_data;
fs/semfs/semfs_fsops.c:	lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_fsops.c:	if (vnodearray_num(semfs->semfs_vnodes) > 0) {
fs/semfs/semfs_fsops.c:		lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_fsops.c:	lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_fsops.c:	semfs->semfs_tablelock = lock_create("semfs_table");
fs/semfs/semfs_fsops.c:	if (semfs->semfs_tablelock == NULL) {
fs/semfs/semfs_fsops.c:	semfs->semfs_vnodes = vnodearray_create();
fs/semfs/semfs_fsops.c:	if (semfs->semfs_vnodes == NULL) {
fs/semfs/semfs_fsops.c:	semfs->semfs_sems = semfs_semarray_create();
fs/semfs/semfs_fsops.c:	if (semfs->semfs_sems == NULL) {
fs/semfs/semfs_fsops.c:	semfs->semfs_dirlock = lock_create("semfs_dir");
fs/semfs/semfs_fsops.c:	if (semfs->semfs_dirlock == NULL) {
fs/semfs/semfs_fsops.c:	semfs->semfs_dents = semfs_direntryarray_create();
fs/semfs/semfs_fsops.c:	if (semfs->semfs_dents == NULL) {
fs/semfs/semfs_fsops.c:	semfs->semfs_absfs.fs_data = semfs;
fs/semfs/semfs_fsops.c:	semfs->semfs_absfs.fs_ops = &semfs_fsops;
fs/semfs/semfs_fsops.c:	lock_destroy(semfs->semfs_dirlock);
fs/semfs/semfs_fsops.c:	semfs_semarray_destroy(semfs->semfs_sems);
fs/semfs/semfs_fsops.c:	vnodearray_destroy(semfs->semfs_vnodes);
fs/semfs/semfs_fsops.c:	lock_destroy(semfs->semfs_tablelock);
fs/semfs/semfs_fsops.c:	result = vfs_addfs("sem", &semfs->semfs_absfs);
fs/semfs/semfs_obj.c:	sem->sems_lock = lock_create(lockname);
fs/semfs/semfs_obj.c:	if (sem->sems_lock == NULL) {
fs/semfs/semfs_obj.c:	sem->sems_cv = cv_create(cvname);
fs/semfs/semfs_obj.c:	if (sem->sems_cv == NULL) {
fs/semfs/semfs_obj.c:	sem->sems_count = 0;
fs/semfs/semfs_obj.c:	sem->sems_hasvnode = false;
fs/semfs/semfs_obj.c:	sem->sems_linked = false;
fs/semfs/semfs_obj.c:	lock_destroy(sem->sems_lock);
fs/semfs/semfs_obj.c:	cv_destroy(sem->sems_cv);
fs/semfs/semfs_obj.c:	lock_destroy(sem->sems_lock);
fs/semfs/semfs_obj.c:	KASSERT(lock_do_i_hold(semfs->semfs_tablelock));
fs/semfs/semfs_obj.c:	num = semfs_semarray_num(semfs->semfs_sems);
fs/semfs/semfs_obj.c:		if (semfs_semarray_get(semfs->semfs_sems, i) == NULL) {
fs/semfs/semfs_obj.c:			semfs_semarray_set(semfs->semfs_sems, i, sem);
fs/semfs/semfs_obj.c:	return semfs_semarray_add(semfs->semfs_sems, sem, ret);
fs/semfs/semfs_obj.c:	dent->semd_name = kstrdup(name);
fs/semfs/semfs_obj.c:	if (dent->semd_name == NULL) {
fs/semfs/semfs_obj.c:	dent->semd_semnum = semnum;
fs/semfs/semfs_obj.c:	kfree(dent->semd_name);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	if (semv->semv_semnum == SEMFS_ROOTDIR) {
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	*ret = semv->semv_semnum == SEMFS_ROOTDIR ? S_IFDIR : S_IFREG;
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	if (semv->semv_semnum != SEMFS_ROOTDIR) {
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	sem = semfs_semarray_get(semfs->semfs_sems, semnum);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	struct semfs *semfs = semv->semv_semfs;
fs/semfs/semfs_vnops.c:	return semfs_getsembynum(semfs, semv->semv_semnum);
fs/semfs/semfs_vnops.c:	if (sem->sems_count > 0 || newcount == 0) {
fs/semfs/semfs_vnops.c:		cv_signal(sem->sems_cv, sem->sems_lock);
fs/semfs/semfs_vnops.c:		cv_broadcast(sem->sems_cv, sem->sems_lock);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	lock_acquire(sem->sems_lock);
fs/semfs/semfs_vnops.c:	buf->st_size = sem->sems_count;
fs/semfs/semfs_vnops.c:	buf->st_nlink = sem->sems_linked ? 1 : 0;
fs/semfs/semfs_vnops.c:	lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:	buf->st_mode = S_IFREG | 0666;
fs/semfs/semfs_vnops.c:	buf->st_blocks = 0;
fs/semfs/semfs_vnops.c:	buf->st_dev = 0;
fs/semfs/semfs_vnops.c:	buf->st_ino = semv->semv_semnum;
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	lock_acquire(sem->sems_lock);
fs/semfs/semfs_vnops.c:	while (uio->uio_resid > 0) {
fs/semfs/semfs_vnops.c:		if (sem->sems_count > 0) {
fs/semfs/semfs_vnops.c:			consume = uio->uio_resid;
fs/semfs/semfs_vnops.c:			if (consume > sem->sems_count) {
fs/semfs/semfs_vnops.c:				consume = sem->sems_count;
fs/semfs/semfs_vnops.c:			DEBUG(DB_SEMFS, "semfs: sem%u: P, count %u -> %u\n",
fs/semfs/semfs_vnops.c:			      semv->semv_semnum, sem->sems_count,
fs/semfs/semfs_vnops.c:			      sem->sems_count - consume);
fs/semfs/semfs_vnops.c:			sem->sems_count -= consume;
fs/semfs/semfs_vnops.c:			uio->uio_resid -= consume;
fs/semfs/semfs_vnops.c:		if (uio->uio_resid == 0) {
fs/semfs/semfs_vnops.c:		if (sem->sems_count == 0) {
fs/semfs/semfs_vnops.c:			      semv->semv_semnum);
fs/semfs/semfs_vnops.c:			cv_wait(sem->sems_cv, sem->sems_lock);
fs/semfs/semfs_vnops.c:	lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	lock_acquire(sem->sems_lock);
fs/semfs/semfs_vnops.c:	while (uio->uio_resid > 0) {
fs/semfs/semfs_vnops.c:		newcount = sem->sems_count + uio->uio_resid;
fs/semfs/semfs_vnops.c:		if (newcount < sem->sems_count) {
fs/semfs/semfs_vnops.c:			lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:		DEBUG(DB_SEMFS, "semfs: sem%u: V, count %u -> %u\n",
fs/semfs/semfs_vnops.c:		      semv->semv_semnum, sem->sems_count, newcount);
fs/semfs/semfs_vnops.c:		sem->sems_count = newcount;
fs/semfs/semfs_vnops.c:		uio->uio_resid = 0;
fs/semfs/semfs_vnops.c:	lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:	const unsigned max = (unsigned)-1;
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	lock_acquire(sem->sems_lock);
fs/semfs/semfs_vnops.c:	sem->sems_count = newcount;
fs/semfs/semfs_vnops.c:	lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *dirsemv = dirvn->vn_data;
fs/semfs/semfs_vnops.c:	struct semfs *semfs = dirsemv->semv_semfs;
fs/semfs/semfs_vnops.c:	KASSERT(uio->uio_offset >= 0);
fs/semfs/semfs_vnops.c:	pos = uio->uio_offset;
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	num = semfs_direntryarray_num(semfs->semfs_dents);
fs/semfs/semfs_vnops.c:		dent = semfs_direntryarray_get(semfs->semfs_dents, pos);
fs/semfs/semfs_vnops.c:		result = uiomove(dent->semd_name, strlen(dent->semd_name),
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	struct semfs *semfs = semv->semv_semfs;
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	buf->st_size = semfs_direntryarray_num(semfs->semfs_dents);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	buf->st_mode = S_IFDIR | 1777;
fs/semfs/semfs_vnops.c:	buf->st_nlink = 2;
fs/semfs/semfs_vnops.c:	buf->st_blocks = 0;
fs/semfs/semfs_vnops.c:	buf->st_dev = 0;
fs/semfs/semfs_vnops.c:	buf->st_ino = SEMFS_ROOTDIR;
fs/semfs/semfs_vnops.c:	struct semfs_vnode *dirsemv = dirvn->vn_data;
fs/semfs/semfs_vnops.c:	struct semfs *semfs = dirsemv->semv_semfs;
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	num = semfs_direntryarray_num(semfs->semfs_dents);
fs/semfs/semfs_vnops.c:		dent = semfs_direntryarray_get(semfs->semfs_dents, i);
fs/semfs/semfs_vnops.c:		if (!strcmp(dent->semd_name, name)) {
fs/semfs/semfs_vnops.c:				lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:			result = semfs_getvnode(semfs, dent->semd_semnum,
fs/semfs/semfs_vnops.c:			lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:		semfs_direntryarray_set(semfs->semfs_dents, empty, dent);
fs/semfs/semfs_vnops.c:		result = semfs_direntryarray_add(semfs->semfs_dents, dent,
fs/semfs/semfs_vnops.c:	sem->sems_linked = true;
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	semfs_direntryarray_set(semfs->semfs_dents, empty, NULL);
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	semfs_semarray_set(semfs->semfs_sems, semnum, NULL);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *dirsemv = dirvn->vn_data;
fs/semfs/semfs_vnops.c:	struct semfs *semfs = dirsemv->semv_semfs;
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	num = semfs_direntryarray_num(semfs->semfs_dents);
fs/semfs/semfs_vnops.c:		dent = semfs_direntryarray_get(semfs->semfs_dents, i);
fs/semfs/semfs_vnops.c:		if (!strcmp(name, dent->semd_name)) {
fs/semfs/semfs_vnops.c:			sem = semfs_getsembynum(semfs, dent->semd_semnum);
fs/semfs/semfs_vnops.c:			lock_acquire(sem->sems_lock);
fs/semfs/semfs_vnops.c:			KASSERT(sem->sems_linked);
fs/semfs/semfs_vnops.c:			sem->sems_linked = false;
fs/semfs/semfs_vnops.c:			if (sem->sems_hasvnode == false) {
fs/semfs/semfs_vnops.c:				lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:				semfs_semarray_set(semfs->semfs_sems,
fs/semfs/semfs_vnops.c:						   dent->semd_semnum, NULL);
fs/semfs/semfs_vnops.c:				lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:				lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:				lock_release(sem->sems_lock);
fs/semfs/semfs_vnops.c:			semfs_direntryarray_set(semfs->semfs_dents, i, NULL);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	struct semfs_vnode *dirsemv = dirvn->vn_data;
fs/semfs/semfs_vnops.c:	struct semfs *semfs = dirsemv->semv_semfs;
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	num = semfs_direntryarray_num(semfs->semfs_dents);
fs/semfs/semfs_vnops.c:		dent = semfs_direntryarray_get(semfs->semfs_dents, i);
fs/semfs/semfs_vnops.c:		if (!strcmp(path, dent->semd_name)) {
fs/semfs/semfs_vnops.c:			result = semfs_getvnode(semfs, dent->semd_semnum,
fs/semfs/semfs_vnops.c:			lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_dirlock);
fs/semfs/semfs_vnops.c:	vnode_cleanup(&semv->semv_absvn);
fs/semfs/semfs_vnops.c: * Reclaim - drop a vnode that's no longer in use.
fs/semfs/semfs_vnops.c:	struct semfs_vnode *semv = vn->vn_data;
fs/semfs/semfs_vnops.c:	struct semfs *semfs = semv->semv_semfs;
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	/* vnode refcount is protected by the vnode's ->vn_countlock */
fs/semfs/semfs_vnops.c:	spinlock_acquire(&vn->vn_countlock);
fs/semfs/semfs_vnops.c:	if (vn->vn_refcount > 1) {
fs/semfs/semfs_vnops.c:		vn->vn_refcount--;
fs/semfs/semfs_vnops.c:		spinlock_release(&vn->vn_countlock);
fs/semfs/semfs_vnops.c:		lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	spinlock_release(&vn->vn_countlock);
fs/semfs/semfs_vnops.c:	num = vnodearray_num(semfs->semfs_vnodes);
fs/semfs/semfs_vnops.c:		vn2 = vnodearray_get(semfs->semfs_vnodes, i);
fs/semfs/semfs_vnops.c:			vnodearray_remove(semfs->semfs_vnodes, i);
fs/semfs/semfs_vnops.c:	if (semv->semv_semnum != SEMFS_ROOTDIR) {
fs/semfs/semfs_vnops.c:		sem = semfs_semarray_get(semfs->semfs_sems, semv->semv_semnum);
fs/semfs/semfs_vnops.c:		KASSERT(sem->sems_hasvnode);
fs/semfs/semfs_vnops.c:		sem->sems_hasvnode = false;
fs/semfs/semfs_vnops.c:		if (sem->sems_linked == false) {
fs/semfs/semfs_vnops.c:			semfs_semarray_set(semfs->semfs_sems,
fs/semfs/semfs_vnops.c:					   semv->semv_semnum, NULL);
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	semv->semv_semfs = semfs;
fs/semfs/semfs_vnops.c:	semv->semv_semnum = semnum;
fs/semfs/semfs_vnops.c:	result = vnode_init(&semv->semv_absvn, optable,
fs/semfs/semfs_vnops.c:			    &semfs->semfs_absfs, semv);
fs/semfs/semfs_vnops.c:	lock_acquire(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	num = vnodearray_num(semfs->semfs_vnodes);
fs/semfs/semfs_vnops.c:		vn = vnodearray_get(semfs->semfs_vnodes, i);
fs/semfs/semfs_vnops.c:		semv = vn->vn_data;
fs/semfs/semfs_vnops.c:		if (semv->semv_semnum == semnum) {
fs/semfs/semfs_vnops.c:			lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:		lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	result = vnodearray_add(semfs->semfs_vnodes, &semv->semv_absvn, NULL);
fs/semfs/semfs_vnops.c:		lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:		sem = semfs_semarray_get(semfs->semfs_sems, semnum);
fs/semfs/semfs_vnops.c:		KASSERT(sem->sems_hasvnode == false);
fs/semfs/semfs_vnops.c:		sem->sems_hasvnode = true;
fs/semfs/semfs_vnops.c:	lock_release(semfs->semfs_tablelock);
fs/semfs/semfs_vnops.c:	*ret = &semv->semv_absvn;
fs/sfs/sfs_balloc.c:	/* static -> automatically initialized to zero */
fs/sfs/sfs_balloc.c:	result = bitmap_alloc(sfs->sfs_freemap, diskblock);
fs/sfs/sfs_balloc.c:	sfs->sfs_freemapdirty = true;
fs/sfs/sfs_balloc.c:	if (*diskblock >= sfs->sfs_sb.sb_nblocks) {
fs/sfs/sfs_balloc.c:		bitmap_unmark(sfs->sfs_freemap, *diskblock);
fs/sfs/sfs_balloc.c:	bitmap_unmark(sfs->sfs_freemap, diskblock);
fs/sfs/sfs_balloc.c:	sfs->sfs_freemapdirty = true;
fs/sfs/sfs_balloc.c:	if (diskblock >= sfs->sfs_sb.sb_nblocks) {
fs/sfs/sfs_balloc.c:	return bitmap_isset(sfs->sfs_freemap, diskblock);
fs/sfs/sfs_bmap.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_bmap.c:		block = sv->sv_i.sfi_direct[fileblock];
fs/sfs/sfs_bmap.c:			sv->sv_i.sfi_direct[fileblock] = block;
fs/sfs/sfs_bmap.c:			sv->sv_dirty = true;
fs/sfs/sfs_bmap.c:			      "marked free\n", block, fileblock, sv->sv_ino);
fs/sfs/sfs_bmap.c:	fileblock -= SFS_NDIRECT;
fs/sfs/sfs_bmap.c:	idblock = sv->sv_i.sfi_indirect;
fs/sfs/sfs_bmap.c:		sv->sv_i.sfi_indirect = idblock;
fs/sfs/sfs_bmap.c:		sv->sv_dirty = true;
fs/sfs/sfs_bmap.c:		      block, fileblock, sv->sv_ino);
fs/sfs/sfs_bmap.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_bmap.c:		block = sv->sv_i.sfi_direct[i];
fs/sfs/sfs_bmap.c:			sv->sv_i.sfi_direct[i] = 0;
fs/sfs/sfs_bmap.c:			sv->sv_dirty = true;
fs/sfs/sfs_bmap.c:	idblock = sv->sv_i.sfi_indirect;
fs/sfs/sfs_bmap.c:	highblock = baseblock + SFS_DBPERIDB - 1;
fs/sfs/sfs_bmap.c:			sv->sv_i.sfi_indirect = 0;
fs/sfs/sfs_bmap.c:			sv->sv_dirty = true;
fs/sfs/sfs_bmap.c:	sv->sv_i.sfi_size = len;
fs/sfs/sfs_bmap.c:	sv->sv_dirty = true;
fs/sfs/sfs_dir.c:	KASSERT(sv->sv_i.sfi_type == SFS_TYPE_DIR);
fs/sfs/sfs_dir.c:	size = sv->sv_i.sfi_size;
fs/sfs/sfs_dir.c:		      sv->sv_ino, size);
fs/sfs/sfs_dir.c:			/* Free slot - report it back if one was requested */
fs/sfs/sfs_dir.c:			tsd.sfd_name[sizeof(tsd.sfd_name)-1] = 0;
fs/sfs/sfs_dir.c:	int emptyslot = -1;
fs/sfs/sfs_dir.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_dir.c:	if ((*ret)->sv_i.sfi_linkcount == 0) {
fs/sfs/sfs_dir.c:		      name, (*ret)->sv_ino, sv->sv_ino);
fs/sfs/sfs_fsops.c: * Filesystem-level interface routines.
fs/sfs/sfs_fsops.c:#define SFS_FS_NBLOCKS(sfs)        ((sfs)->sfs_sb.sb_nblocks)
fs/sfs/sfs_fsops.c: * The free block bitmap consists of SFS_FREEMAPBLOCKS 512-byte
fs/sfs/sfs_fsops.c:	freemapdata = bitmap_getdata(sfs->sfs_freemap);
fs/sfs/sfs_fsops.c:	 * struct sfs_fs - essentially the same object. This can be a
fs/sfs/sfs_fsops.c:	 *     struct sfs_fs        <-------------\
fs/sfs/sfs_fsops.c:         *           :   sfs_absfs (struct fs)    |   <------\
fs/sfs/sfs_fsops.c:         *           :      :  fs_data  ----------/          |
fs/sfs/sfs_fsops.c:	sfs = fs->fs_data;
fs/sfs/sfs_fsops.c:	num = vnodearray_num(sfs->sfs_vnodes);
fs/sfs/sfs_fsops.c:		struct vnode *v = vnodearray_get(sfs->sfs_vnodes, i);
fs/sfs/sfs_fsops.c:	if (sfs->sfs_freemapdirty) {
fs/sfs/sfs_fsops.c:		sfs->sfs_freemapdirty = false;
fs/sfs/sfs_fsops.c:	if (sfs->sfs_superdirty) {
fs/sfs/sfs_fsops.c:		result = sfs_writeblock(sfs, SFS_SUPER_BLOCK, &sfs->sfs_sb,
fs/sfs/sfs_fsops.c:					sizeof(sfs->sfs_sb));
fs/sfs/sfs_fsops.c:		sfs->sfs_superdirty = false;
fs/sfs/sfs_fsops.c:	struct sfs_fs *sfs = fs->fs_data;
fs/sfs/sfs_fsops.c:	ret = sfs->sfs_sb.sb_volname;
fs/sfs/sfs_fsops.c:	if (sfs->sfs_freemap != NULL) {
fs/sfs/sfs_fsops.c:		bitmap_destroy(sfs->sfs_freemap);
fs/sfs/sfs_fsops.c:	vnodearray_destroy(sfs->sfs_vnodes);
fs/sfs/sfs_fsops.c:	KASSERT(sfs->sfs_device == NULL);
fs/sfs/sfs_fsops.c:	struct sfs_fs *sfs = fs->fs_data;
fs/sfs/sfs_fsops.c:	if (vnodearray_num(sfs->sfs_vnodes) > 0) {
fs/sfs/sfs_fsops.c:	KASSERT(sfs->sfs_superdirty == false);
fs/sfs/sfs_fsops.c:	KASSERT(sfs->sfs_freemapdirty == false);
fs/sfs/sfs_fsops.c:	sfs->sfs_device = NULL;
fs/sfs/sfs_fsops.c:	 * Make sure our on-disk structures aren't messed up
fs/sfs/sfs_fsops.c:	/* abstract vfs-level fs */
fs/sfs/sfs_fsops.c:	sfs->sfs_absfs.fs_data = sfs;
fs/sfs/sfs_fsops.c:	sfs->sfs_absfs.fs_ops = &sfs_fsops;
fs/sfs/sfs_fsops.c:	sfs->sfs_superdirty = false;
fs/sfs/sfs_fsops.c:	sfs->sfs_device = NULL;
fs/sfs/sfs_fsops.c:	sfs->sfs_vnodes = vnodearray_create();
fs/sfs/sfs_fsops.c:	if (sfs->sfs_vnodes == NULL) {
fs/sfs/sfs_fsops.c:	sfs->sfs_freemap = NULL;
fs/sfs/sfs_fsops.c:	sfs->sfs_freemapdirty = false;
fs/sfs/sfs_fsops.c: * filesystem-specific mount routine. Said routine takes a device and
fs/sfs/sfs_fsops.c:	if (dev->d_blocksize != SFS_BLOCKSIZE) {
fs/sfs/sfs_fsops.c:			dev->d_blocksize);
fs/sfs/sfs_fsops.c:	sfs->sfs_device = dev;
fs/sfs/sfs_fsops.c:	result = sfs_readblock(sfs, SFS_SUPER_BLOCK, &sfs->sfs_sb,
fs/sfs/sfs_fsops.c:			       sizeof(sfs->sfs_sb));
fs/sfs/sfs_fsops.c:	if (sfs->sfs_sb.sb_magic != SFS_MAGIC) {
fs/sfs/sfs_fsops.c:			sfs->sfs_sb.sb_magic,
fs/sfs/sfs_fsops.c:	if (sfs->sfs_sb.sb_nblocks > dev->d_blocks) {
fs/sfs/sfs_fsops.c:		kprintf("sfs: warning - fs has %u blocks, device has %u\n",
fs/sfs/sfs_fsops.c:			sfs->sfs_sb.sb_nblocks, dev->d_blocks);
fs/sfs/sfs_fsops.c:	sfs->sfs_sb.sb_volname[sizeof(sfs->sfs_sb.sb_volname)-1] = 0;
fs/sfs/sfs_fsops.c:	sfs->sfs_freemap = bitmap_create(SFS_FS_FREEMAPBITS(sfs));
fs/sfs/sfs_fsops.c:	if (sfs->sfs_freemap == NULL) {
fs/sfs/sfs_fsops.c:	*ret = &sfs->sfs_absfs;
fs/sfs/sfs_fsops.c: * Actual function called from high-level code to mount an sfs.
fs/sfs/sfs_inode.c: * Inode-level operations and vnode/inode lifecycle logic.
fs/sfs/sfs_inode.c: * Write an on-disk inode structure back out to disk.
fs/sfs/sfs_inode.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_inode.c:	if (sv->sv_dirty) {
fs/sfs/sfs_inode.c:		result = sfs_writeblock(sfs, sv->sv_ino, &sv->sv_i,
fs/sfs/sfs_inode.c:					sizeof(sv->sv_i));
fs/sfs/sfs_inode.c:		sv->sv_dirty = false;
fs/sfs/sfs_inode.c: * Called when the vnode refcount (in-memory usage count) hits zero.
fs/sfs/sfs_inode.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_inode.c:	struct sfs_fs *sfs = v->vn_fs->fs_data;
fs/sfs/sfs_inode.c:	spinlock_acquire(&v->vn_countlock);
fs/sfs/sfs_inode.c:	if (v->vn_refcount != 1) {
fs/sfs/sfs_inode.c:		KASSERT(v->vn_refcount>1);
fs/sfs/sfs_inode.c:		v->vn_refcount--;
fs/sfs/sfs_inode.c:		spinlock_release(&v->vn_countlock);
fs/sfs/sfs_inode.c:	spinlock_release(&v->vn_countlock);
fs/sfs/sfs_inode.c:	/* If there are no on-disk references to the file either, erase it. */
fs/sfs/sfs_inode.c:	if (sv->sv_i.sfi_linkcount == 0) {
fs/sfs/sfs_inode.c:	/* If there are no on-disk references, discard the inode */
fs/sfs/sfs_inode.c:	if (sv->sv_i.sfi_linkcount==0) {
fs/sfs/sfs_inode.c:		sfs_bfree(sfs, sv->sv_ino);
fs/sfs/sfs_inode.c:	num = vnodearray_num(sfs->sfs_vnodes);
fs/sfs/sfs_inode.c:		struct vnode *v2 = vnodearray_get(sfs->sfs_vnodes, i);
fs/sfs/sfs_inode.c:		struct sfs_vnode *sv2 = v2->vn_data;
fs/sfs/sfs_inode.c:		      sv->sv_ino);
fs/sfs/sfs_inode.c:	vnodearray_remove(sfs->sfs_vnodes, ix);
fs/sfs/sfs_inode.c:	vnode_cleanup(&sv->sv_absvn);
fs/sfs/sfs_inode.c:	num = vnodearray_num(sfs->sfs_vnodes);
fs/sfs/sfs_inode.c:		v = vnodearray_get(sfs->sfs_vnodes, i);
fs/sfs/sfs_inode.c:		sv = v->vn_data;
fs/sfs/sfs_inode.c:		if (!sfs_bused(sfs, sv->sv_ino)) {
fs/sfs/sfs_inode.c:			      sv->sv_ino);
fs/sfs/sfs_inode.c:		if (sv->sv_ino==ino) {
fs/sfs/sfs_inode.c:			VOP_INCREF(&sv->sv_absvn);
fs/sfs/sfs_inode.c:	result = sfs_readblock(sfs, ino, &sv->sv_i, sizeof(sv->sv_i));
fs/sfs/sfs_inode.c:	sv->sv_dirty = false;
fs/sfs/sfs_inode.c:		KASSERT(sv->sv_i.sfi_type == SFS_TYPE_INVAL);
fs/sfs/sfs_inode.c:		sv->sv_i.sfi_type = forcetype;
fs/sfs/sfs_inode.c:		sv->sv_dirty = true;
fs/sfs/sfs_inode.c:	switch (sv->sv_i.sfi_type) {
fs/sfs/sfs_inode.c:		      ino, sv->sv_i.sfi_type);
fs/sfs/sfs_inode.c:	result = vnode_init(&sv->sv_absvn, ops, &sfs->sfs_absfs, sv);
fs/sfs/sfs_inode.c:	sv->sv_ino = ino;
fs/sfs/sfs_inode.c:	result = vnodearray_add(sfs->sfs_vnodes, &sv->sv_absvn, NULL);
fs/sfs/sfs_inode.c:		vnode_cleanup(&sv->sv_absvn);
fs/sfs/sfs_inode.c:	struct sfs_fs *sfs = fs->fs_data;
fs/sfs/sfs_inode.c:	if (sv->sv_i.sfi_type != SFS_TYPE_DIR) {
fs/sfs/sfs_inode.c:		      sv->sv_i.sfi_type);
fs/sfs/sfs_inode.c:	*ret = &sv->sv_absvn;
fs/sfs/sfs_io.c:// Basic block-level I/O routines
fs/sfs/sfs_io.c:	      uio->uio_rw == UIO_READ ? "read" : "write",
fs/sfs/sfs_io.c:	      uio->uio_offset / SFS_BLOCKSIZE);
fs/sfs/sfs_io.c:	result = DEVOP_IO(sfs->sfs_device, uio);
fs/sfs/sfs_io.c:		 * or the seek address we gave wasn't sector-aligned,
fs/sfs/sfs_io.c:				uio->uio_offset / SFS_BLOCKSIZE);
fs/sfs/sfs_io.c:				uio->uio_offset / SFS_BLOCKSIZE, tries);
fs/sfs/sfs_io.c:// File-level I/O
fs/sfs/sfs_io.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_io.c:	bool doalloc = (uio->uio_rw==UIO_WRITE);
fs/sfs/sfs_io.c:	fileblock = uio->uio_offset / SFS_BLOCKSIZE;
fs/sfs/sfs_io.c:		KASSERT(uio->uio_rw == UIO_READ);
fs/sfs/sfs_io.c:	if (uio->uio_rw == UIO_WRITE) {
fs/sfs/sfs_io.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_io.c:	bool doalloc = (uio->uio_rw==UIO_WRITE);
fs/sfs/sfs_io.c:	fileblock = uio->uio_offset / SFS_BLOCKSIZE;
fs/sfs/sfs_io.c:		 * No block - fill with zeros.
fs/sfs/sfs_io.c:		KASSERT(uio->uio_rw == UIO_READ);
fs/sfs/sfs_io.c:	saveoff = uio->uio_offset;
fs/sfs/sfs_io.c:	uio->uio_offset = diskoff;
fs/sfs/sfs_io.c:	KASSERT(uio->uio_resid >= SFS_BLOCKSIZE);
fs/sfs/sfs_io.c:	saveres = uio->uio_resid;
fs/sfs/sfs_io.c:	uio->uio_resid = diskres;
fs/sfs/sfs_io.c:	uio->uio_offset = (uio->uio_offset - diskoff) + saveoff;
fs/sfs/sfs_io.c:	uio->uio_resid = (uio->uio_resid - diskres) + saveres;
fs/sfs/sfs_io.c: * Do I/O of a whole region of data, whether or not it's block-aligned.
fs/sfs/sfs_io.c:	origresid = uio->uio_resid;
fs/sfs/sfs_io.c:	if (uio->uio_rw == UIO_READ) {
fs/sfs/sfs_io.c:		off_t size = sv->sv_i.sfi_size;
fs/sfs/sfs_io.c:		off_t endpos = uio->uio_offset + uio->uio_resid;
fs/sfs/sfs_io.c:		if (uio->uio_offset >= size) {
fs/sfs/sfs_io.c:			/* At or past EOF - just return */
fs/sfs/sfs_io.c:			extraresid = endpos - size;
fs/sfs/sfs_io.c:			KASSERT(uio->uio_resid > extraresid);
fs/sfs/sfs_io.c:			uio->uio_resid -= extraresid;
fs/sfs/sfs_io.c:	blkoff = uio->uio_offset % SFS_BLOCKSIZE;
fs/sfs/sfs_io.c:		uint32_t len = SFS_BLOCKSIZE - blkoff;
fs/sfs/sfs_io.c:		if (len > uio->uio_resid) {
fs/sfs/sfs_io.c:			len = uio->uio_resid;
fs/sfs/sfs_io.c:	if (uio->uio_resid==0) {
fs/sfs/sfs_io.c:	 * Now we should be block-aligned. Do the remaining whole blocks.
fs/sfs/sfs_io.c:	KASSERT(uio->uio_offset % SFS_BLOCKSIZE == 0);
fs/sfs/sfs_io.c:	nblocks = uio->uio_resid / SFS_BLOCKSIZE;
fs/sfs/sfs_io.c:	KASSERT(uio->uio_resid < SFS_BLOCKSIZE);
fs/sfs/sfs_io.c:	if (uio->uio_resid > 0) {
fs/sfs/sfs_io.c:		result = sfs_partialio(sv, uio, 0, uio->uio_resid);
fs/sfs/sfs_io.c:	if (uio->uio_resid != origresid &&
fs/sfs/sfs_io.c:	    uio->uio_rw == UIO_WRITE &&
fs/sfs/sfs_io.c:	    uio->uio_offset > (off_t)sv->sv_i.sfi_size) {
fs/sfs/sfs_io.c:		sv->sv_i.sfi_size = uio->uio_offset;
fs/sfs/sfs_io.c:		sv->sv_dirty = true;
fs/sfs/sfs_io.c:	uio->uio_resid += extraresid;
fs/sfs/sfs_io.c:	struct sfs_fs *sfs = sv->sv_absvn.vn_fs->fs_data;
fs/sfs/sfs_io.c:		if (endpos > (off_t)sv->sv_i.sfi_size) {
fs/sfs/sfs_io.c:			sv->sv_i.sfi_size = endpos;
fs/sfs/sfs_io.c:			sv->sv_dirty = true;
fs/sfs/sfs_vnops.c: * File-level (vnode) interface routines.
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	KASSERT(uio->uio_rw==UIO_READ);
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	KASSERT(uio->uio_rw==UIO_WRITE);
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	result = VOP_GETTYPE(v, &statbuf->st_mode);
fs/sfs/sfs_vnops.c:	statbuf->st_size = sv->sv_i.sfi_size;
fs/sfs/sfs_vnops.c:	statbuf->st_nlink = sv->sv_i.sfi_linkcount;
fs/sfs/sfs_vnops.c:	statbuf->st_blocks = 0;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	switch (sv->sv_i.sfi_type) {
fs/sfs/sfs_vnops.c:	      sv->sv_ino, sv->sv_i.sfi_type);
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = vv->vn_data;
fs/sfs/sfs_vnops.c:	KASSERT(sv->sv_ino == SFS_ROOTDIR_INO);
fs/sfs/sfs_vnops.c:	/* send back the empty string - just return */
fs/sfs/sfs_vnops.c:	struct sfs_fs *sfs = v->vn_fs->fs_data;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:		*ret = &newguy->sv_absvn;
fs/sfs/sfs_vnops.c:	/* Didn't exist - create it */
fs/sfs/sfs_vnops.c:	result = sfs_dir_link(sv, name, newguy->sv_ino, NULL);
fs/sfs/sfs_vnops.c:		VOP_DECREF(&newguy->sv_absvn);
fs/sfs/sfs_vnops.c:	newguy->sv_i.sfi_linkcount++;
fs/sfs/sfs_vnops.c:	newguy->sv_dirty = true;
fs/sfs/sfs_vnops.c:	*ret = &newguy->sv_absvn;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = dir->vn_data;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *f = file->vn_data;
fs/sfs/sfs_vnops.c:	KASSERT(file->vn_fs == dir->vn_fs);
fs/sfs/sfs_vnops.c:	if (f->sv_i.sfi_type == SFS_TYPE_DIR) {
fs/sfs/sfs_vnops.c:	result = sfs_dir_link(sv, name, f->sv_ino, NULL);
fs/sfs/sfs_vnops.c:	f->sv_i.sfi_linkcount++;
fs/sfs/sfs_vnops.c:	f->sv_dirty = true;
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = dir->vn_data;
fs/sfs/sfs_vnops.c:		KASSERT(victim->sv_i.sfi_linkcount > 0);
fs/sfs/sfs_vnops.c:		victim->sv_i.sfi_linkcount--;
fs/sfs/sfs_vnops.c:		victim->sv_dirty = true;
fs/sfs/sfs_vnops.c:	VOP_DECREF(&victim->sv_absvn);
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = d1->vn_data;
fs/sfs/sfs_vnops.c:	KASSERT(sv->sv_ino == SFS_ROOTDIR_INO);
fs/sfs/sfs_vnops.c:	KASSERT(g1->sv_i.sfi_type == SFS_TYPE_FILE);
fs/sfs/sfs_vnops.c:	result = sfs_dir_link(sv, n2, g1->sv_ino, &slot2);
fs/sfs/sfs_vnops.c:	g1->sv_i.sfi_linkcount++;
fs/sfs/sfs_vnops.c:	g1->sv_dirty = true;
fs/sfs/sfs_vnops.c:	KASSERT(g1->sv_i.sfi_linkcount>0);
fs/sfs/sfs_vnops.c:	g1->sv_i.sfi_linkcount--;
fs/sfs/sfs_vnops.c:	g1->sv_dirty = true;
fs/sfs/sfs_vnops.c:	VOP_DECREF(&g1->sv_absvn);
fs/sfs/sfs_vnops.c:	g1->sv_i.sfi_linkcount--;
fs/sfs/sfs_vnops.c:	VOP_DECREF(&g1->sv_absvn);
fs/sfs/sfs_vnops.c: * Since we don't support subdirectories, this is very easy -
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	if (sv->sv_i.sfi_type != SFS_TYPE_DIR) {
fs/sfs/sfs_vnops.c:	VOP_INCREF(&sv->sv_absvn);
fs/sfs/sfs_vnops.c:	*ret = &sv->sv_absvn;
fs/sfs/sfs_vnops.c: * Since we don't support subdirectories, it's easy - just look up the
fs/sfs/sfs_vnops.c:	struct sfs_vnode *sv = v->vn_data;
fs/sfs/sfs_vnops.c:	if (sv->sv_i.sfi_type != SFS_TYPE_DIR) {
fs/sfs/sfs_vnops.c:	*ret = &final->sv_absvn;
gdbscripts/array:Usage: threadarray curproc->p_threads
gdbscripts/array:Usage: vnodearray sfs->sfs_vnodes
gdbscripts/wchan:	set $pnm = $p->wc_name
gdbscripts/wchan:	set $pth = &$p->wc_threads
gdbscripts/wchan:	set $pct = $pth->tl_count
gdbscripts/wchan:	printf "wchan %u @0x%x: %-16s %u\n", $i, $p, $pnm, $pct
gdbscripts/wchan:    set $pnm = $p->wc_name
gdbscripts/wchan:    set $pth = $p->wc_threads
gdbscripts/wchan:    printf "wchan %u @0x%x: %-16s %u:\n", $arg0, $p, $pnm, $pct
gdbscripts/wchan:    set $t = $arg0.tl_head.tln_next->tln_self
gdbscripts/wchan:	printf "thread %s @0x%x\n", $t->t_name, $t
gdbscripts/wchan:	set $t = $t->t_listnode.tln_next->tln_self
gdbscripts/wchan:Usage: threadlist mycpu->c_runqueue
gdbscripts/wchan:	set $id = $c->c_isidle
gdbscripts/wchan:	set $ln = $c->c_spinlocks
gdbscripts/wchan:	set $t = $c->c_curthread
gdbscripts/wchan:	set $zom = $c->c_zombies.tl_count
gdbscripts/wchan:	set $rn = $c->c_runqueue.tl_count
gdbscripts/wchan:	    printf "current: %s @0x%x\n", $t->t_name, $t
gdbscripts/wchan:	    threadlist $c->c_zombies
gdbscripts/wchan:	    threadlist $c->c_zombies
include/array.h:/*-
include/array.h: * create - allocate an array.
include/array.h: * destroy - destroy an allocated array.
include/array.h: * init - initialize an array in space externally allocated.
include/array.h: * cleanup - clean up an array in space externally allocated.
include/array.h: * num - return number of elements in array.
include/array.h: * get - return element no. INDEX.
include/array.h: * set - set element no. INDEX to VAL.
include/array.h: * preallocate - allocate space without changing size; may fail and
include/array.h: * setsize - change size to NUM elements; may fail and return error.
include/array.h: * add - append VAL to end of array; return its index in INDEX_RET if
include/array.h: * remove - excise entry INDEX and slide following entries down to
include/array.h:	return a->num;
include/array.h:	ARRAYASSERT(index < a->num);
include/array.h:	return a->v[index];
include/array.h:	ARRAYASSERT(index < a->num);
include/array.h:	a->v[index] = val;
include/array.h:	index = a->num;
include/array.h:	a->v[index] = val;
include/array.h:		array_init(&a->arr);				\
include/array.h:		array_cleanup(&a->arr);				\
include/array.h:		array_init(&a->arr);				\
include/array.h:		array_cleanup(&a->arr);				\
include/array.h:		return array_num(&a->arr);			\
include/array.h:		return (T *)array_get(&a->arr, index);		\
include/array.h:		array_set(&a->arr, index, (void *)val);		\
include/array.h:		return array_preallocate(&a->arr, num);		\
include/array.h:		return array_setsize(&a->arr, num);		\
include/array.h:		return array_add(&a->arr, (void *)val, index_ret); \
include/array.h:		array_remove(&a->arr, index);			\
include/bitmap.h: * Fixed-size array of bits. (Intended for storage management.)
include/bitmap.h: *     bitmap_create  - allocate a new bitmap object.
include/bitmap.h: *     bitmap_getdata - return pointer to raw bit data (for I/O).
include/bitmap.h: *     bitmap_alloc   - locate a cleared bit, set it, and return its index.
include/bitmap.h: *     bitmap_mark    - set a clear bit by its index.
include/bitmap.h: *     bitmap_unmark  - clear a set bit by its index.
include/bitmap.h: *     bitmap_isset   - return whether a particular bit is set or not.
include/bitmap.h: *     bitmap_destroy - destroy bitmap.
include/cdefs.h: * Build-time assertion. Doesn't generate any code. The error message
include/cdefs.h:#define COMPILE_ASSERT(x) ((void)sizeof(struct { unsigned : ((x)?1:-1); }))
include/cdefs.h: * functions, the compiler can (1) generate a file-static out-of-line
include/cdefs.h: * copy of the function, (2) generate a global out-of-line copy of the
include/cdefs.h: * function, or (3) generate no out-of-line copy of the function.
include/cdefs.h: * no out-of-line copy exists the build may fail at link time with
include/cdefs.h: * global out-of-line copy, it will generate one such copy for every
include/cdefs.h: * defined symbols and build failure. The file-static option isn't
include/cdefs.h: * out-of-line copy of the inline function per source file that uses
include/cdefs.h: * an out-of-line version. Then we define the inline functions
include/cdefs.h: * ensures that an out-of-line definition appears, and furthermore
include/cdefs.h: * ensures that the out-of-line definition is the same as the inline
include/cdefs.h: * generate an out-of-line copy" and "extern inline" means "generate a
include/cdefs.h: * global out-of-line copy". In gcc, going back far longer than C99,
include/cdefs.h: * is defined if the behavior is C99-compliant.
include/cdefs.h:/* gcc's non-C99 inline semantics */
include/clock.h: * Time-related definitions.
include/clock.h: * sub: ret = t1 - t2
include/copyinout.h: * copyin copies LEN bytes from a user-space address USERSRC to a
include/copyinout.h: * kernel-space address DEST.
include/copyinout.h: * copyout copies LEN bytes from a kernel-space address SRC to a
include/copyinout.h: * user-space address USERDEST.
include/copyinout.h: * copyinstr copies a null-terminated string of at most LEN bytes from
include/copyinout.h: * a user-space address USERSRC to a kernel-space address DEST, and
include/copyinout.h: * null-terminated on success. LEN and GOT include the null terminator.
include/copyinout.h: * copyoutstr copies a null-terminated string of at most LEN bytes from
include/copyinout.h: * a kernel-space address SRC to a user-space address USERDEST, and
include/copyinout.h: * null-terminated on success. LEN and GOT include the null terminator.
include/copyinout.h: * These functions are machine-dependent; however, a common version
include/cpu.h: * Per-cpu structure
include/cpu.h: * cpu->c_self should always be used when *using* the address of curcpu
include/cpu.h: * a pointer with a fixed address and a per-cpu mapping in the MMU.
include/cpu.h:	unsigned c_hardware_number;	/* Hardware-defined cpu number */
include/cpu.h:	 * If c_numshootdown is -1 (TLBSHOOTDOWN_ALL), all mappings
include/cpu.h:	 * struct tlbshootdown is machine-dependent and might
include/cpu.h:#define TLBSHOOTDOWN_ALL  (-1)
include/cpu.h: * cpu_create creates a cpu; it is suitable for calling from driver-
include/cpu.h: * or bus-specific code that looks for secondary CPUs.
include/cpu.h: * cpu_start_secondary is the platform-dependent assembly language
include/cpu.h: * Hardware-level interrupt on/off, for the current CPU.
include/cpu.h: * cpu_idle() sits around (in a low-power state if possible) until it
include/cpu.h: * cpu_halt sits around (in a low-power state if possible) until the
include/current.h: * The machine-dependent header should define either curcpu or curthread
include/current.h: * This material is machine-dependent because on some platforms it is
include/current.h: * curcpu->c_curthread, and on others to keep track of curthread and
include/current.h: * make curcpu be curthread->t_cpu.
include/current.h: * on-chip somewhere in some fashion.
include/current.h: * constant. (But one has to remember to use curcpu->c_self as the
include/current.h: * can be stored in a supervisor-mode register, where it can be set up
include/current.h:#define curthread curcpu->c_curthread
include/current.h:#define curcpu curthread->t_cpu
include/current.h:#define curproc (curthread->t_proc)
include/device.h: * Filesystem-namespace-accessible device.
include/device.h:	void *d_data;		/* device-specific data */
include/device.h: *      devop_eachopen - called on each open call to allow denying the open
include/device.h: *      devop_io - for both reads and writes (the uio indicates the direction)
include/device.h: *      devop_ioctl - miscellaneous control operations
include/device.h:#define DEVOP_EACHOPEN(d, f)	((d)->d_ops->devop_eachopen(d, f))
include/device.h:#define DEVOP_IO(d, u)		((d)->d_ops->devop_io(d, u))
include/device.h:#define DEVOP_IOCTL(d, op, p)	((d)->d_ops->devop_ioctl(d, op, p))
include/device.h:/* Create vnode for a vfs-level device. */
include/device.h:/* Initialization functions for builtin vfs-level devices. */
include/elf.h: *     32-bit only
include/elf.h:/* Offsets for the 1-byte fields within e_ident[] */
include/elf.h:#define	EI_CLASS	4	/* File class - always ELFCLASS32 */
include/elf.h:#define	EI_DATA		5	/* Data encoding - ELFDATA2LSB or ELFDATA2MSB*/
include/elf.h:#define	EI_VERSION	6	/* ELF version - EV_CURRENT*/
include/elf.h:#define	ELFCLASS32	1	/* 32-bit objects */
include/elf.h:#define	ELFCLASS64	2	/* 64-bit objects */
include/elf.h:#define	ELFOSABI_HPUX		1	/* HP-UX operating system */
include/elf.h:#define	EM_MIPS_RS3_LE	10	/* MIPS RS3000 Little-endian */
include/elf.h:#define	EM_PARISC	15	/* Hewlett-Packard PA-RISC */
include/elf.h:#define	EM_RH32		38	/* TRW RH-32 */
include/elf.h:#define	EM_SH		42	/* Hitachi Super-H */
include/elf.h:#define	EM_MIPS_X	51	/* Stanford MIPS-X */
include/elf.h: * "Program Header" - runtime segment header.
include/elf.h: * Note: if p_memsz > p_filesz, the leftover space should be zero-filled.
include/elf.h:	uint32_t	p_align;     /* Required alignment - can ignore */
include/endian.h:/* Utility functions for handling 64-bit values; see bswap.c for description */
include/filetable.h: * OPEN_MAX) instead of a dynamically sized array (using array.h) --
include/filetable.h: * or even to make it dynamic with the limit being user-settable. (See
include/filetable.h: * Because we only have single-threaded processes, the file table is
include/filetable.h: * create -  Construct an empty file table.
include/filetable.h: * destroy - Wipe out a file table, closing anything open in it.
include/filetable.h: * copy -    Clone a file table.
include/filetable.h: * okfd -    Check if a file handle is in range.
include/filetable.h: * get/put - Retrieve a fd for use and put it back when done. (Checks
include/filetable.h: * place -   Insert a file and return the fd.
include/filetable.h: * placeat - Insert a file at a specific slot and return the file
include/fs.h: * fs_data is a pointer to filesystem-specific data.
include/fs.h: *      fsop_sync       - Flush all dirty buffers to disk.
include/fs.h: *      fsop_getvolname - Return volume name of filesystem.
include/fs.h: *      fsop_getroot    - Return root vnode of filesystem.
include/fs.h: *      fsop_unmount    - Attempt unmount of filesystem.
include/fs.h:#define FSOP_SYNC(fs)        ((fs)->fs_ops->fsop_sync(fs))
include/fs.h:#define FSOP_GETVOLNAME(fs)  ((fs)->fs_ops->fsop_getvolname(fs))
include/fs.h:#define FSOP_GETROOT(fs, ret) ((fs)->fs_ops->fsop_getroot(fs, ret))
include/fs.h:#define FSOP_UNMOUNT(fs)     ((fs)->fs_ops->fsop_unmount(fs))
include/kern/endian.h: * Machine-independent and exported endianness definitions.
include/kern/errmsg.h:	"Cross-device link",          /* EXDEV */
include/kern/errmsg.h:	"Read-only file system",      /* EROFS */
include/kern/fcntl.h:#define F_GETFD         1       /* get per-handle flags */
include/kern/fcntl.h:#define F_SETFD         2       /* set per-handle flags */
include/kern/fcntl.h:#define F_GETFL         3       /* get per-file flags (O_* open flags) */
include/kern/fcntl.h:#define F_SETFL         4       /* set per-file flags (O_* open flags) */
include/kern/fcntl.h:#define FD_CLOEXEC      1       /* close-on-exec */
include/kern/iovec.h:                userptr_t  iov_ubase;	/* user-supplied pointer */
include/kern/iovec.h:                void      *iov_kbase;	/* kernel-supplied pointer */
include/kern/iovec.h:	void *iov_base;			/* user-supplied pointer */
include/kern/limits.h: * Constants for libc's <limits.h> - system limits.
include/kern/limits.h: * These are Unix-style limits that Unix defines; you can change them
include/kern/limits.h:/* Max bytes for atomic pipe I/O -- see description in the pipe() man page */
include/kern/resource.h:#define PRIO_MIN	(-20)
include/kern/resource.h:#define RUSAGE_CHILDREN	(-1)
include/kern/resource.h:	__counter_t ru_ixrss;		/* text memory usage (kb-ticks) */
include/kern/resource.h:	__counter_t ru_idrss;		/* data memory usage (kb-ticks) */
include/kern/resource.h:	__counter_t ru_isrss;		/* stack memory usage (kb-ticks) */
include/kern/resource.h:	__counter_t ru_nswap;		/* whole-process swaps (count) */
include/kern/sfs.h: * SFS definitions visible to userspace. This covers the on-disk format
include/kern/sfs.h:#define SFS_ROUNDUP(a,b)       ((((a)+(b)-1)/(b))*b)
include/kern/sfs.h: * On-disk superblock
include/kern/sfs.h: * On-disk inode
include/kern/sfs.h:	uint32_t sfi_waste[128-3-SFS_NDIRECT];	/* unused space, set to 0 */
include/kern/sfs.h: * On-disk directory entry
include/kern/signal.h: * Machine-independent definitions for signals.
include/kern/signal.h:#define SIGUSR1		20	/* Application-defined */
include/kern/signal.h:#define SIGUSR2		31	/* Application-defined */
include/kern/socket.h: * Socket-related definitions, for <sys/socket.h>.
include/kern/socket.h:   char __ss_pad5[_SS_SIZE - sizeof(__u64) - sizeof(__u32) - 4*sizeof(__u8)];
include/kern/socket.h:	int cmsg_type;		/* protocol-specific message type */
include/kern/stattypes.h: * Non-underscore versions of the names can be gotten from <stat.h>
include/kern/syscall.h: * more-or-less standard Unix system call that someone might
include/kern/syscall.h: * conceivably implement on OS/161. The commented-out ones are ones
include/kern/syscall.h://                              -- Process-related --
include/kern/syscall.h://                              -- File-handle-related --
include/kern/syscall.h://                              -- Pathname-related --
include/kern/syscall.h://                              -- Any-file-related --
include/kern/syscall.h://                              -- Sockets and networking --
include/kern/syscall.h://                              -- Time-related --
include/kern/syscall.h://                              -- Other --
include/kern/time.h: * Time-related definitions, for <sys/time.h> and others.
include/kern/time.h:#define ITIMER_REAL	0	/* Real (wall-clock) time. */
include/kern/types.h:/* Get machine-dependent types. */
include/kern/types.h: * Machine-independent types visible to user level.
include/kern/types.h:typedef int __socklen_t;   /* Socket-related length */
include/kern/wait.h:#define WAIT_ANY     (-1)	/* Any child process. */
include/kern/errno.h:#define EXDEV           24     /* Cross-device link */
include/kern/errno.h:#define EROFS           35     /* Read-only file system */
include/lib.h: * Note that there's also a COMPILE_ASSERT for compile-time checks;
include/lib.h:#include "opt-noasserts.h"
include/lib.h: * Low-level console access.
include/lib.h: * Higher-level console output.
include/lib.h:#define DIVROUNDUP(a,b) (((a)+(b)-1)/(b))
include/mainbus.h:/* Bus-level interrupt handler, called from cpu-level trap/interrupt code */
include/mainbus.h:/* Switch on an inter-processor interrupt. (Low-level.) */
include/mainbus.h: * The various ways to shut down the system. (These are very low-level
include/mainbus.h: * and should generally not be called directly - md_poweroff, for
include/membar.h: * and membar_any_store unless rolling your own lock-like objects,
include/membar.h: * using atomic operations, implementing lock-free data structures, or
include/membar.h:/* Inlining support - for making sure an out-of-line copy gets built */
include/openfile.h: * Open files are reference-counted because they get shared via fork
include/setjmp.h: * Kernel-level setjmp/longjmp.
include/setjmp.h:/* Get (machine-dependent) definition of jmp_buf. */
include/sfs.h: * Get on-disk structures and constants that are made available to
include/sfs.h: * In-memory inode
include/sfs.h:	struct sfs_dinode sv_i;		/* copy of on-disk inode */
include/sfs.h: * In-memory info for a whole fs volume
include/sfs.h:	struct sfs_superblock sfs_sb;	/* copy of on-disk superblock */
include/signal.h:/* In-kernel signal definitions. Get both the MD and MI parts. */
include/spinlock.h: * Spinlocks. While the guts are machine-dependent, the structure and the
include/spinlock.h:/* Inlining support - for making sure an out-of-line copy gets built */
include/spinlock.h:/* Get the machine-dependent bits. */
include/spinlock.h: * release	Release the lock. May re-enable interrupts.
include/spl.h:/* Inlining support - for making sure an out-of-line copy gets built */
include/spl.h: * Machine-independent interface to interrupt enable/disable.
include/spl.h: * priority levels and functions for setting them - spltty(),
include/spl.h: * Lower-level functions for explicitly raising and lowering
include/stat.h:/* Provide non-underscore names. */
include/stdarg.h:/* Get __PF() for declaring printf-like functions. */
include/stdarg.h: * As of gcc 3.0, the stdarg declarations can be made machine-
include/stdarg.h: * The strings passed to the function might not be null-terminated; the
include/threadlist.h: * AmigaOS-style linked list of threads.
include/threadlist.h: * itervar->tln_next is null, not when itervar itself becomes null.
include/threadlist.h: * ->tln_self always points to the thread that contains the
include/threadlist.h: *    (struct thread *)((char *)node - offsetof(struct thread, t_listnode))
include/threadlist.h:/* Add and remove: in middle. (TL is needed to maintain ->tl_count.) */
include/threadlist.h:	for ((itervar) = (tl).tl_head.tln_next->tln_self; \
include/threadlist.h:	     (itervar) = (itervar)->t_listnode.tln_next->tln_self)
include/threadlist.h:	for ((itervar) = (tl).tl_tail.tln_prev->tln_self; \
include/threadlist.h:	     (itervar) = (itervar)->t_listnode.tln_prev->tln_self)
include/threadprivate.h: * Subsystem-private thread defs.
include/threadprivate.h: * threads directory) so the machine-dependent thread code can include
include/threadprivate.h: * it. This is one of the drawbacks of putting all machine-dependent
include/threadprivate.h:/* Initialize or clean up the machine-dependent portion of struct thread */
include/threadprivate.h: * Machine-dependent functions for working on switchframes.
include/threadprivate.h: * Note that while the functions themselves are machine-dependent, their
include/threadprivate.h:/* Assembler-level context switch. */
include/types.h: *     - Every source file includes this file, <types.h>, first.
include/types.h: *     - Every other header file may assume this file has been
include/types.h: *     - Some exceptions to the previous rules exist among the headers
include/types.h: *       kernel only indirectly via other, non-exported, headers, as
include/types.h: *     - Every source or header file should include each file it
include/types.h: *     - As a matter of convention, the ordering of include files in
include/types.h: *       lower-level code like <spinlock.h> should come before
include/types.h: *       higher-level code like <addrspace.h> or <vfs.h>. This
include/types.h: *           4. Low-level code: locks, trapframes, etc.
include/types.h: *       Subsystem-private headers (the only extant example is
include/types.h:/* Get machine-dependent types not visible to userland. */
include/types.h: * Define userptr_t as a pointer to a one-byte struct, so it won't mix
include/types.h: * Proper (non-underscore) names for the types that are exposed to
include/types.h:/* machine-dependent from <kern/machine/types.h>... */
include/types.h:/* ...and machine-independent from <kern/types.h>. */
include/vfs.h: * The VFS layer translates operations on abstract on-disk files or
include/vfs.h:struct vnode;  /* abstract structure for an on-disk file (vnode.h) */
include/vfs.h: * VFS layer low-level operations.
include/vfs.h: *    vfs_setcurdir - change current directory of current thread by vnode
include/vfs.h: *    vfs_clearcurdir - change current directory of current thread to "none"
include/vfs.h: *    vfs_getcurdir - retrieve vnode of current directory of current thread
include/vfs.h: *    vfs_sync      - force all dirty buffers to disk
include/vfs.h: *    vfs_getroot   - get root vnode for the filesystem named DEVNAME
include/vfs.h: *    vfs_getdevname - get mounted device name for the filesystem passed in
include/vfs.h: * VFS layer mid-level operations.
include/vfs.h: *    vfs_lookup     - Like VOP_LOOKUP, but takes a full device:path name,
include/vfs.h: *    vfs_lookparent - Likewise, for VOP_LOOKPARENT.
include/vfs.h: * VFS layer high-level operations on pathnames
include/vfs.h: *    vfs_open         - Open or create a file. FLAGS/MODE per the syscall.
include/vfs.h: *    vfs_readlink     - Read contents of a symlink into a uio.
include/vfs.h: *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.
include/vfs.h: *    vfs_mkdir        - Create a directory. MODE per the syscall.
include/vfs.h: *    vfs_link         - Create a hard link to a file.
include/vfs.h: *    vfs_remove       - Delete a file.
include/vfs.h: *    vfs_rmdir        - Delete a directory.
include/vfs.h: *    vfs_rename       - rename a file.
include/vfs.h: *    vfs_chdir  - Change current directory of current thread by name.
include/vfs.h: *    vfs_getcwd - Retrieve name of current directory of current thread.
include/vfs.h: *    vfs_close  - Close a vnode opened with vfs_open. Does not fail.
include/vfs.h: *    vfs_bootstrap - Call during system initialization to allocate
include/vfs.h: *    vfs_setbootfs - Set the filesystem that paths beginning with a
include/vfs.h: *    vfs_clearbootfs - Clear the bootfs filesystem. This should be
include/vfs.h: *    vfs_adddev    - Add a device to the VFS named device list. If
include/vfs.h: *    vfs_addfs     - Add a hardwired filesystem to the VFS named device
include/vfs.h: *                    intended for filesystem-devices like emufs, and
include/vfs.h: *    vfs_mount     - Attempt to mount a filesystem on a device. The
include/vfs.h: *    vfs_unmount   - Unmount the filesystem presently mounted on the
include/vfs.h: *    vfs_unmountall - Unmount all mounted filesystems.
include/vfs.h: * Global one-big-lock for all filesystem operations.
include/vnode.h: * filesystem-independent code to interact usefully with multiple sets
include/vnode.h: * Abstract low-level file.
include/vnode.h:	void *vn_data;                  /* Filesystem-specific data */
include/vnode.h: * that expands to vnode->vn_ops->vop_foo(vnode, args). The operations
include/vnode.h: *    vop_eachopen    - Called on *each* open() of a file. Can be used to
include/vnode.h: *                      above the VFS layer - use vfs_open() to open vnodes.
include/vnode.h: *    vop_reclaim     - Called when vnode is no longer in use.
include/vnode.h: *    vop_read        - Read data from file to uio, at offset specified
include/vnode.h: *    vop_readlink    - Read the contents of a symlink into a uio.
include/vnode.h: *    vop_getdirentry - Read a single filename from a directory into a
include/vnode.h: *                      On non-directory objects, return ENOTDIR.
include/vnode.h: *    vop_write       - Write data from uio to file at offset specified
include/vnode.h: *    vop_ioctl       - Perform ioctl operation OP on file using data
include/vnode.h: *    vop_stat        - Return info about a file. The pointer is a
include/vnode.h: *    vop_gettype     - Return type of file. The values for file types
include/vnode.h: *    vop_isseekable  - Check if this file is seekable. All regular files
include/vnode.h: *    vop_fsync       - Force any dirty buffers associated with this file
include/vnode.h: *    vop_mmap        - Map file into memory. If you implement this
include/vnode.h: *    vop_truncate    - Forcibly set size of file to the length passed
include/vnode.h: *    vop_namefile    - Compute pathname relative to filesystem root
include/vnode.h: *    vop_creat       - Create a regular file named NAME in the passed
include/vnode.h: *    vop_symlink     - Create symlink named NAME in the passed directory,
include/vnode.h: *    vop_mkdir       - Make directory NAME in the passed directory PARENTDIR.
include/vnode.h: *    vop_link        - Create hard link, with name NAME, to file FILE
include/vnode.h: *    vop_remove      - Delete non-directory object NAME from passed
include/vnode.h: *    vop_rmdir       - Delete directory object NAME from passed
include/vnode.h: *    vop_rename      - Rename file NAME1 in directory VN1 to be
include/vnode.h: *    vop_lookup      - Parse PATHNAME relative to the passed directory
include/vnode.h: *    vop_lookparent  - Parse PATHNAME relative to the passed directory
include/vnode.h:#define __VOP(vn, sym) (vnode_check(vn, #sym), (vn)->vn_ops->vop_##sym)
include/proc.h:/* This is the process structure for the kernel and for kernel-only threads. */
include/syscall.h: * Prototypes for IN-KERNEL entry points for system call implementations.
include/test.h: * Declarations for test code and other miscellaneous high-level
include/test.h:/* Routine for running a user-level program. */
include/addrspace.h:#include "opt-dumbvm.h"
include/addrspace.h: * Address space - data structure associated with the virtual memory
include/addrspace.h: *    as_create - create a new empty address space. You need to make
include/addrspace.h: *                return NULL on out-of-memory error.
include/addrspace.h: *    as_copy   - create a new address space that is an exact copy of
include/addrspace.h: *    as_activate - make curproc's address space the one currently
include/addrspace.h: *    as_deactivate - unload curproc's address space so it isn't
include/addrspace.h: *    as_destroy - dispose of an address space. You may need to change
include/addrspace.h: *                the way this works if implementing user-level threads.
include/addrspace.h: *    as_define_region - set up a region of memory within the address
include/addrspace.h: *    as_prepare_load - this is called before actually loading from an
include/addrspace.h: *    as_complete_load - this is called when loading from an executable
include/addrspace.h: *    as_define_stack - set up the stack region in the address space.
include/addrspace.h: *    load_elf - load an ELF user program executable into the current
include/synch.h: * Dijkstra-style semaphore.
include/synch.h:extern struct lock locks[PID_MAX-PID_MIN];
include/synch.h: *    lock_acquire - Get the lock. Only one thread can hold the lock at the
include/synch.h: *    lock_release - Free the lock. Only the thread holding the lock may do
include/synch.h: *    lock_do_i_hold - Return true if the current thread holds the lock;
include/synch.h: *	TestAndSet - try to grab the lock and return 1 if the lock is already held 
include/synch.h:extern struct cv cvs[PID_MAX-PID_MIN];
include/synch.h: *    cv_wait      - Release the supplied lock, go to sleep, and, after
include/synch.h: *                   waking up again, re-acquire the lock.
include/synch.h: *    cv_signal    - Wake up one thread that's sleeping on this CV.
include/synch.h: *    cv_broadcast - Wake up all threads sleeping on this CV.
include/thread.h:/* get machine-dependent defs */
include/thread.h:#define STACK_MASK  (~(vaddr_t)(STACK_SIZE-1))
include/thread.h:	struct thread_machdep t_machdep; /* Any machine-dependent goo */
include/thread.h:	void *t_stack;			/* Kernel-level stack */
include/thread.h:	 * Exercise for the student: why is this material per-thread
include/thread.h:	 * rather than per-cpu or global?
include/vm.h: * VM system-related definitions.
include/vm.h:/* Fault-type arguments to vm_fault() */
lib/array.c:/*-
lib/array.c:	a->num = a->max = 0;
lib/array.c:	a->v = NULL;
lib/array.c:	 * Require array to be empty - helps avoid memory leaks since
lib/array.c:	ARRAYASSERT(a->num == 0);
lib/array.c:	kfree(a->v);
lib/array.c:	a->v = NULL;
lib/array.c:	if (num > a->max) {
lib/array.c:		newmax = a->max;
lib/array.c:		newptr = kmalloc(newmax*sizeof(*a->v));
lib/array.c:		memcpy(newptr, a->v, a->num*sizeof(*a->v));
lib/array.c:		kfree(a->v);
lib/array.c:		a->v = newptr;
lib/array.c:		a->max = newmax;
lib/array.c:	a->num = num;
lib/array.c:        ARRAYASSERT(a->num <= a->max);
lib/array.c:        ARRAYASSERT(index < a->num);
lib/array.c:        num_to_move = a->num - (index + 1);
lib/array.c:        memmove(a->v + index, a->v + index+1, num_to_move*sizeof(void *));
lib/array.c:        a->num--;
lib/bitmap.c: * Fixed-size array of bits. (Intended for storage management.)
lib/bitmap.c: * bitmap data saved on disk becomes endian-dependent, which is a
lib/bitmap.c:        b->v = kmalloc(words*sizeof(WORD_TYPE));
lib/bitmap.c:        if (b->v == NULL) {
lib/bitmap.c:        bzero(b->v, words*sizeof(WORD_TYPE));
lib/bitmap.c:        b->nbits = nbits;
lib/bitmap.c:                unsigned j, ix = words-1;
lib/bitmap.c:                unsigned overbits = nbits - ix*BITS_PER_WORD;
lib/bitmap.c:                KASSERT(nbits / BITS_PER_WORD == words-1);
lib/bitmap.c:                        b->v[ix] |= ((WORD_TYPE)1 << j);
lib/bitmap.c:        return b->v;
lib/bitmap.c:        unsigned maxix = DIVROUNDUP(b->nbits, BITS_PER_WORD);
lib/bitmap.c:                if (b->v[ix]!=WORD_ALLBITS) {
lib/bitmap.c:                                if ((b->v[ix] & mask)==0) {
lib/bitmap.c:                                        b->v[ix] |= mask;
lib/bitmap.c:                                        KASSERT(*index < b->nbits);
lib/bitmap.c:        KASSERT(index < b->nbits);
lib/bitmap.c:        KASSERT((b->v[ix] & mask)==0);
lib/bitmap.c:        b->v[ix] |= mask;
lib/bitmap.c:        KASSERT(index < b->nbits);
lib/bitmap.c:        KASSERT((b->v[ix] & mask)!=0);
lib/bitmap.c:        b->v[ix] &= ~mask;
lib/bitmap.c:        return (b->v[ix] & mask);
lib/bitmap.c:        kfree(b->v);
lib/bswap.c: * Unconditional byte-swap functions.
lib/bswap.c: * byte-swap machine instructions (if those exist) than something
lib/bswap.c: * loop-based.
lib/bswap.c: * Network byte order byte-swap functions.
lib/bswap.c: *    *s are for "short" (16-bit)
lib/bswap.c: *    *l are for "long" (32-bit)
lib/bswap.c: *    *ll are for "long long" (64-bit)
lib/bswap.c: * Network byte order is big-endian.
lib/bswap.c: * big-endian, so these functions are actually all empty.
lib/bswap.c: * Some utility functions for handling 64-bit values.
lib/bswap.c: * join32to64 pastes two adjoining 32-bit values together in the right
lib/bswap.c: * way to treat them as a 64-bit value, depending on endianness.
lib/bswap.c: * The 32-bit arguments should be passed in the order they appear in
lib/kgets.c:		/* Only allow the normal 7-bit ascii */
lib/kgets.c:		if (ch>=32 && ch<127 && pos < maxlen-1) {
lib/kgets.c:			pos--;
lib/kgets.c:			/* ^C - return empty string */
lib/kgets.c:			/* ^R - reprint input */
lib/kgets.c:			/* ^U - erase line */
lib/kgets.c:				pos--;
lib/kgets.c:			/* ^W - erase word */
lib/kgets.c:			while (pos > 0 && buf[pos-1]==' ') {
lib/kgets.c:				pos--;
lib/kgets.c:			while (pos > 0 && buf[pos-1]!=' ') {
lib/kgets.c:				pos--;
lib/kprintf.c:/* Lock for non-polled kprintfs */
lib/kprintf.c:		&& curthread->t_in_interrupt == false
lib/kprintf.c:		&& curthread->t_curspl == 0
lib/kprintf.c:		&& curcpu->c_spinlocks == 0;
lib/kprintf.c:	 * This is not excessively paranoid - these things DO happen!
lib/time.c:	ret->tv_nsec = ts1->tv_nsec + ts2->tv_nsec;
lib/time.c:	ret->tv_sec = ts1->tv_sec + ts2->tv_sec;
lib/time.c:	if (ret->tv_nsec >= 1000000000) {
lib/time.c:		ret->tv_nsec -= 1000000000;
lib/time.c:		ret->tv_sec += 1;
lib/time.c: * ts1 - ts2
lib/time.c:	if (r.tv_nsec < ts2->tv_nsec) {
lib/time.c:		r.tv_sec--;
lib/time.c:	r.tv_nsec -= ts2->tv_nsec;
lib/time.c:	r.tv_sec -= ts2->tv_sec;
lib/uio.c:	if (uio->uio_rw != UIO_READ && uio->uio_rw != UIO_WRITE) {
lib/uio.c:		panic("uiomove: Invalid uio_rw %d\n", (int) uio->uio_rw);
lib/uio.c:	if (uio->uio_segflg==UIO_SYSSPACE) {
lib/uio.c:		KASSERT(uio->uio_space == NULL);
lib/uio.c:		KASSERT(uio->uio_space == proc_getas());
lib/uio.c:	while (n > 0 && uio->uio_resid > 0) {
lib/uio.c:		iov = uio->uio_iov;
lib/uio.c:		size = iov->iov_len;
lib/uio.c:			uio->uio_iov++;
lib/uio.c:			uio->uio_iovcnt--;
lib/uio.c:			if (uio->uio_iovcnt == 0) {
lib/uio.c:		switch (uio->uio_segflg) {
lib/uio.c:			    if (uio->uio_rw == UIO_READ) {
lib/uio.c:				    memmove(iov->iov_kbase, ptr, size);
lib/uio.c:				    memmove(ptr, iov->iov_kbase, size);
lib/uio.c:			    iov->iov_kbase = ((char *)iov->iov_kbase+size);
lib/uio.c:			    if (uio->uio_rw == UIO_READ) {
lib/uio.c:				    result = copyout(ptr, iov->iov_ubase,size);
lib/uio.c:				    result = copyin(iov->iov_ubase, ptr, size);
lib/uio.c:			    iov->iov_ubase += size;
lib/uio.c:				  (int)uio->uio_segflg);
lib/uio.c:		iov->iov_len -= size;
lib/uio.c:		uio->uio_resid -= size;
lib/uio.c:		uio->uio_offset += size;
lib/uio.c:		n -= size;
lib/uio.c:	KASSERT(uio->uio_rw == UIO_READ);
lib/uio.c:		n -= amt;
lib/uio.c:	iov->iov_kbase = kbuf;
lib/uio.c:	iov->iov_len = len;
lib/uio.c:	u->uio_iov = iov;
lib/uio.c:	u->uio_iovcnt = 1;
lib/uio.c:	u->uio_offset = pos;
lib/uio.c:	u->uio_resid = len;
lib/uio.c:	u->uio_segflg = UIO_SYSSPACE;
lib/uio.c:	u->uio_rw = rw;
lib/uio.c:	u->uio_space = NULL;
lib/uio.c:	iov->iov_ubase = buf;
lib/uio.c:	iov->iov_len = len;
lib/uio.c:	u->uio_iov = iov;
lib/uio.c:	u->uio_iovcnt = 1;
lib/uio.c:	u->uio_offset = offset;
lib/uio.c:	u->uio_resid = len;
lib/uio.c:	u->uio_segflg = UIO_USERSPACE;
lib/uio.c:	u->uio_rw = rw;
lib/uio.c:	u->uio_space = proc_getas();
main/main.c:    "Copyright (c) 2000, 2001-2005, 2008-2011, 2013, 2014\n"
main/main.c:	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n",
main/main.c:	KASSERT(curthread->t_curspl > 0);
main/main.c:	KASSERT(curthread->t_curspl == 0);
main/main.c:	/* Now do pseudo-devices. */
main/main.c:	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
main/menu.c:#include "opt-synchprobs.h"
main/menu.c:#include "opt-sfs.h"
main/menu.c:#include "opt-net.h"
main/menu.c: * In-kernel menu and command dispatcher.
main/menu.c: * so you should have it call your system-calls-assignment waitpid
main/menu.c:		"synchronization-problems kernel.\n");
main/menu.c:	nargs--;
main/menu.c:	uio_kinit(&iov, &ku, buf, sizeof(buf)-1, 0, UIO_READ);
main/menu.c:	buf[sizeof(buf)-1-ku.uio_resid] = 0;
main/menu.c:	if (device[strlen(device)-1]==':') {
main/menu.c:		device[strlen(device)-1] = 0;
main/menu.c:	if (device[strlen(device)-1]==':') {
main/menu.c:		device[strlen(device)-1] = 0;
main/menu.c:	if (device[strlen(device)-1]==':') {
main/menu.c:		device[strlen(device)-1] = 0;
main/menu.c:		kprintf("    %-36s", x[i]);
main/menu.c:	/* in-kernel synchronization problem(s) */
main/menu.c: * Evaluate a command line that may contain multiple semicolon-delimited
main/menu.c: * If "isargs" is set, we're doing command-line processing; print the
proc/proc.c: * The process for the kernel; this holds all the kernel-only threads.
proc/proc.c:	proc->p_name = kstrdup(name);
proc/proc.c:	if (proc->p_name == NULL) {
proc/proc.c:	threadarray_init(&proc->p_threads);
proc/proc.c:	spinlock_init(&proc->p_lock);
proc/proc.c:	proc->p_addrspace = NULL;
proc/proc.c:	proc->p_cwd = NULL;
proc/proc.c:	proc->p_filetable = NULL;
proc/proc.c:	proc->numthreads = 0;
proc/proc.c:	proc->children = NULL;
proc/proc.c:	for(i = 1; i < PID_MAX-1; i++) {
proc/proc.c:	return -1;	// no available pid
proc/proc.c:	array_remove(process_table, proc->pid - 1);
proc/proc.c:	//lock_destroy(array_get(lock_table, proc->pid-1));
proc/proc.c:	//array_remove(lock_table, proc->pid-1);
proc/proc.c:	//cv_destroy(array_get(cv_table, proc->pid-1));
proc/proc.c:	//array_remove(cv_table, proc->pid-1);
proc/proc.c:	if (proc->p_cwd) {
proc/proc.c:		VOP_DECREF(proc->p_cwd);
proc/proc.c:		proc->p_cwd = NULL;
proc/proc.c:	if (proc->p_filetable) {
proc/proc.c:		filetable_destroy(proc->p_filetable);
proc/proc.c:		proc->p_filetable = NULL;
proc/proc.c:	if (proc->p_addrspace) {
proc/proc.c:		 * process is kernel-only; in that case it is normally
proc/proc.c:		 * ok if the MMU and MMU- related data structures
proc/proc.c:			as = proc->p_addrspace;
proc/proc.c:			proc->p_addrspace = NULL;
proc/proc.c:	int x = proc->numthreads;
proc/proc.c:	for(i = 0; i < x - 1; i++) {
proc/proc.c:		threadarray_remove(&proc->p_threads, 0);
proc/proc.c:	threadarray_cleanup(&proc->p_threads);
proc/proc.c:	spinlock_cleanup(&proc->p_lock);
proc/proc.c:	kfree(proc->p_name);
proc/proc.c:	array_setsize(process_table, PID_MAX-1);
proc/proc.c:	array_setsize(status_table, PID_MAX-PID_MIN);
proc/proc.c:	array_setsize(lock_table, PID_MAX-PID_MIN);
proc/proc.c:	array_setsize(cv_table, PID_MAX-PID_MIN);
proc/proc.c:	kproc->pid = 1;
proc/proc.c:	kproc->numthreads = 0;
proc/proc.c:	if(pid == -1) {	// no more pids
proc/proc.c:	newproc->pid = pid + 1;
proc/proc.c:        parents_child->pid = pid+1;
proc/proc.c:        parents_child->exitcode = 0;
proc/proc.c:        parents_child->waiting = 0;
proc/proc.c:        parents_child->exited = 0;
proc/proc.c:        parents_child->next = curproc->children;
proc/proc.c:        curproc->children = parents_child;
proc/proc.c:        newproc->parent = curproc;
proc/proc.c:	newproc->numthreads = 0;
proc/proc.c:	newproc->children = NULL;
proc/proc.c:	newproc->p_addrspace = NULL;
proc/proc.c:	spinlock_acquire(&curproc->p_lock);
proc/proc.c:	if (curproc->p_cwd != NULL) {
proc/proc.c:		VOP_INCREF(curproc->p_cwd);
proc/proc.c:		newproc->p_cwd = curproc->p_cwd;
proc/proc.c:	spinlock_release(&curproc->p_lock);
proc/proc.c: * is not null. (If RET is null, what we're creating is a kernel-only
proc/proc.c:	proc = proc_create(curproc->p_name);
proc/proc.c:	/* do not clone address space -- let caller decide on that */
proc/proc.c:	tbl = curproc->p_filetable;
proc/proc.c:		result = filetable_copy(tbl, &proc->p_filetable);
proc/proc.c:			as_destroy(proc->p_addrspace);
proc/proc.c:			proc->p_addrspace = NULL;
proc/proc.c:	spinlock_acquire(&curproc->p_lock);
proc/proc.c:	/* we don't need to lock proc->p_lock as we have the only reference */
proc/proc.c:	if (curproc->p_cwd != NULL) {
proc/proc.c:		VOP_INCREF(curproc->p_cwd);
proc/proc.c:		proc->p_cwd = curproc->p_cwd;
proc/proc.c:	spinlock_release(&curproc->p_lock);
proc/proc.c:	KASSERT(t->t_proc == NULL);
proc/proc.c:	spinlock_acquire(&proc->p_lock);
proc/proc.c:	result = threadarray_add(&proc->p_threads, t, NULL);
proc/proc.c:	spinlock_release(&proc->p_lock);
proc/proc.c:	proc->numthreads++;
proc/proc.c:	t->t_proc = proc;
proc/proc.c:	proc = t->t_proc;
proc/proc.c:	spinlock_acquire(&proc->p_lock);
proc/proc.c:	num = threadarray_num(&proc->p_threads);
proc/proc.c:		if (threadarray_get(&proc->p_threads, i) == t) {
proc/proc.c:			threadarray_remove(&proc->p_threads, i);
proc/proc.c:			spinlock_release(&proc->p_lock);
proc/proc.c:			t->t_proc = NULL;
proc/proc.c:			proc->numthreads--;
proc/proc.c:	spinlock_release(&proc->p_lock);
proc/proc.c:	spinlock_acquire(&proc->p_lock);
proc/proc.c:	as = proc->p_addrspace;
proc/proc.c:	spinlock_release(&proc->p_lock);
proc/proc.c:	spinlock_acquire(&proc->p_lock);
proc/proc.c:	oldas = proc->p_addrspace;
proc/proc.c:	proc->p_addrspace = newas;
proc/proc.c:	spinlock_release(&proc->p_lock);
synchprobs/bathroom.c:	if(turn == -1) {
synchprobs/bathroom.c:	numMen--;
synchprobs/bathroom.c:	if(turn == -1)
synchprobs/bathroom.c:	numFemale--;
synchprobs/bathroom.c:	turn = -1; // 0 = men's turn; 1 = female's turn
syscall/file_syscalls.c: * File-related system call implementations.
syscall/file_syscalls.c: * open() - get the path with copyinstr, then use openfile_open and
syscall/file_syscalls.c:	result = filetable_place(curproc->p_filetable, file, retval);
syscall/file_syscalls.c:	result = filetable_get(curproc->p_filetable, fd, &file);
syscall/file_syscalls.c:	locked = VOP_ISSEEKABLE(file->of_vnode);
syscall/file_syscalls.c:		lock_acquire(file->of_offsetlock);
syscall/file_syscalls.c:		pos = file->of_offset;
syscall/file_syscalls.c:	if (file->of_accmode == badaccmode) {
syscall/file_syscalls.c:		VOP_READ(file->of_vnode, &useruio) :
syscall/file_syscalls.c:		VOP_WRITE(file->of_vnode, &useruio);
syscall/file_syscalls.c:		file->of_offset = useruio.uio_offset;
syscall/file_syscalls.c:		lock_release(file->of_offsetlock);
syscall/file_syscalls.c:	filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c:	*retval = size - useruio.uio_resid;
syscall/file_syscalls.c:		lock_release(file->of_offsetlock);
syscall/file_syscalls.c:	filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c: * read() - use sys_readwrite
syscall/file_syscalls.c: * write() - use sys_readwrite
syscall/file_syscalls.c: * close() - remove from the file table.
syscall/file_syscalls.c:	ft = curproc->p_filetable;
syscall/file_syscalls.c: * lseek() - manipulate the seek position.
syscall/file_syscalls.c:	result = filetable_get(curproc->p_filetable, fd, &file);
syscall/file_syscalls.c:	if (!VOP_ISSEEKABLE(file->of_vnode)) {
syscall/file_syscalls.c:		filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c:	lock_acquire(file->of_offsetlock);
syscall/file_syscalls.c:		*retval = file->of_offset + offset;
syscall/file_syscalls.c:		result = VOP_STAT(file->of_vnode, &info);
syscall/file_syscalls.c:			lock_release(file->of_offsetlock);
syscall/file_syscalls.c:			filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c:		lock_release(file->of_offsetlock);
syscall/file_syscalls.c:		filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c:		lock_release(file->of_offsetlock);
syscall/file_syscalls.c:		filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c:	/* Success -- update the file structure with the new position. */
syscall/file_syscalls.c:	file->of_offset = *retval;
syscall/file_syscalls.c:	lock_release(file->of_offsetlock);
syscall/file_syscalls.c:	filetable_put(curproc->p_filetable, fd, file);
syscall/file_syscalls.c: * dup2() - clone a file descriptor.
syscall/file_syscalls.c:	ft = curproc->p_filetable;
syscall/file_syscalls.c: * chdir() - change directory. Send the path off to the vfs layer.
syscall/file_syscalls.c: * __getcwd() - get current directory. Make a uio and get the data
syscall/file_syscalls.c:	*retval = buflen - useruio.uio_resid;
syscall/filetable.c:		ft->ft_openfiles[fd] = NULL;
syscall/filetable.c:		if (ft->ft_openfiles[fd] != NULL) {
syscall/filetable.c:			openfile_decref(ft->ft_openfiles[fd]);
syscall/filetable.c:			ft->ft_openfiles[fd] = NULL;
syscall/filetable.c:		file = src->ft_openfiles[fd];
syscall/filetable.c:		dest->ft_openfiles[fd] = file;
syscall/filetable.c:	/* We have a fixed-size table so we don't need to check the size */
syscall/filetable.c:	file = ft->ft_openfiles[fd];
syscall/filetable.c:	KASSERT(ft->ft_openfiles[fd] == file);
syscall/filetable.c:		if (ft->ft_openfiles[fd] == NULL) {
syscall/filetable.c:			ft->ft_openfiles[fd] = file;
syscall/filetable.c: * Consumes a reference to the passed-in openfile object; returns a
syscall/filetable.c:	*oldfile_ret = ft->ft_openfiles[fd];
syscall/filetable.c:	ft->ft_openfiles[fd] = newfile;
syscall/loadelf.c: * Code to load an ELF-format executable into the current address space.
syscall/loadelf.c: *    - first, as_define_region once for each segment of the program;
syscall/loadelf.c: *    - then, as_prepare_load;
syscall/loadelf.c: *    - then it loads each chunk of the program;
syscall/loadelf.c: *    - finally, as_complete_load.
syscall/loadelf.c: * mis-linked executables if that proves desirable. Under normal
syscall/loadelf.c: * If you wanted to support memory-mapped executables you would need
syscall/loadelf.c: * the in-memory segment should be zero-filled.
syscall/loadelf.c:		kprintf("ELF: short read on segment - file truncated?\n");
syscall/loadelf.c:	 * zero-filled. There is no need to do this explicitly,
syscall/loadelf.c:	 * cause it to (maybe only sometimes) not provide zero-filled
syscall/loadelf.c:		fillamt = memsize - filesize;
syscall/loadelf.c:			DEBUG(DB_EXEC, "ELF: Zero-filling %lu more bytes\n",
syscall/loadelf.c:		kprintf("ELF: short read on header - file truncated?\n");
syscall/loadelf.c:	 * Check to make sure it's a 32-bit ELF-version-1 executable
syscall/loadelf.c:	 * Ignore EI_OSABI and EI_ABIVERSION - properly, we should
syscall/loadelf.c:	 * Ordinarily there will be one code segment, one read-only
syscall/loadelf.c:	 * mandated by the ELF standard - we use sizeof(ph) to load,
syscall/loadelf.c:			kprintf("ELF: short read on phdr - file truncated?\n");
syscall/loadelf.c:			kprintf("ELF: short read on phdr - file truncated?\n");
syscall/openfile.c:	file->of_offsetlock = lock_create("openfile");
syscall/openfile.c:	if (file->of_offsetlock == NULL) {
syscall/openfile.c:	spinlock_init(&file->of_reflock);
syscall/openfile.c:	file->of_vnode = vn;
syscall/openfile.c:	file->of_accmode = accmode;
syscall/openfile.c:	file->of_offset = 0;
syscall/openfile.c:	file->of_refcount = 1;
syscall/openfile.c:	vfs_close(file->of_vnode);
syscall/openfile.c:	spinlock_cleanup(&file->of_reflock);
syscall/openfile.c:	lock_destroy(file->of_offsetlock);
syscall/openfile.c:	spinlock_acquire(&file->of_reflock);
syscall/openfile.c:	file->of_refcount++;
syscall/openfile.c:	spinlock_release(&file->of_reflock);
syscall/openfile.c:	spinlock_acquire(&file->of_reflock);
syscall/openfile.c:	if (file->of_refcount == 1) {
syscall/openfile.c:		spinlock_release(&file->of_reflock);
syscall/openfile.c:		KASSERT(file->of_refcount > 1);
syscall/openfile.c:		file->of_refcount--;
syscall/openfile.c:		spinlock_release(&file->of_reflock);
syscall/runprogram.c: * minutiae, like the vfs-level open destroying pathnames.
syscall/runprogram.c:	filetable_placeat(curproc->p_filetable, newfile, fd, &oldfile);
syscall/runprogram.c:	if (curproc->p_filetable == NULL) {
syscall/runprogram.c:		curproc->p_filetable = filetable_create();
syscall/runprogram.c:		if (curproc->p_filetable == NULL) {
syscall/runprogram.c:			argv[i] = (userptr_t) stackptr - total_len;
syscall/runprogram.c:		unsigned long pad = ((stackptr - total_len) - ((argc + 1) * sizeCharPointer)) % 8;
syscall/runprogram.c:		stackptr = (stackptr - total_len) - pad;
syscall/runprogram.c:		stackptr -= sizeCharPointer;
syscall/runprogram.c:		for(i = argc - 1; i >= 0; i--) {
syscall/runprogram.c:			stackptr -= sizeCharPointer;
syscall/getpid.c:        return curproc->pid;
syscall/temp.c: * minutiae, like the vfs-level open destroying pathnames.
syscall/temp.c:	filetable_placeat(curproc->p_filetable, newfile, fd, &oldfile);
syscall/temp.c:			return -1;
syscall/temp.c:				return -1;
syscall/temp.c:				return -1;	
syscall/temp.c:		return -1;
syscall/temp.c:	if (curproc->p_filetable == NULL) {
syscall/temp.c:		curproc->p_filetable = filetable_create();
syscall/temp.c:		if (curproc->p_filetable == NULL) {
syscall/temp.c:	as_destroy(curproc->p_addrspace);
syscall/temp.c:		return -1;
syscall/temp.c:		argv[i] = (userptr_t) stackptr - total_len;	// keep track of string start
syscall/temp.c:	unsigned long pad = ((stackptr - total_len) - ((argc + 1) * sizeCharPointer)) % 8;
syscall/temp.c:	stackptr = (stackptr - total_len) - pad;
syscall/temp.c:	stackptr -= sizeCharPointer;
syscall/temp.c:		return -1;
syscall/temp.c:	for(i = argc - 1; i >= 0; i--) {
syscall/temp.c:		stackptr -= sizeCharPointer;
syscall/temp.c:			return -1;
syscall/temp.c:	return -1;
syscall/temp.c:		return -1;
syscall/temp.c:		while(i--)
syscall/temp.c:		return -1;
syscall/execv.c: * minutiae, like the vfs-level open destroying pathnames.
syscall/execv.c:	filetable_placeat(curproc->p_filetable, newfile, fd, &oldfile);
syscall/execv.c:			return -1;
syscall/execv.c:				return -1;
syscall/execv.c:				return -1;	
syscall/execv.c:		return -1;
syscall/execv.c:	if (curproc->p_filetable == NULL) {
syscall/execv.c:		curproc->p_filetable = filetable_create();
syscall/execv.c:		if (curproc->p_filetable == NULL) {
syscall/execv.c:	l -= (argc - 1) * sizeCharPointer;
syscall/execv.c:	as_destroy(curproc->p_addrspace);
syscall/execv.c:		return -1;
syscall/execv.c:		argv[i] = (userptr_t) stackptr - total_len;	// keep track of string start
syscall/execv.c:		result = copyoutstr(args_buffer+offset, (userptr_t) stackptr - total_len, str_size, NULL);
syscall/execv.c:	pad = ((stackptr - total_len) - ((argc + 1) * sizeCharPointer)) % 8;
syscall/execv.c:	stackptr = (stackptr - total_len) - pad;
syscall/execv.c:	stackptr -= sizeCharPointer;
syscall/execv.c:		return -1;
syscall/execv.c:	for(i = argc - 1; i >= 0; i--) {
syscall/execv.c:		stackptr -= sizeCharPointer;
syscall/execv.c:                        return -1;
syscall/execv.c:	return -1;
syscall/execv.c:		return -1;
syscall/execv.c:		return -1;
syscall/temp2.c: * minutiae, like the vfs-level open destroying pathnames.
syscall/temp2.c:	filetable_placeat(curproc->p_filetable, newfile, fd, &oldfile);
syscall/temp2.c:			return -1;
syscall/temp2.c:				return -1;
syscall/temp2.c:				return -1;	
syscall/temp2.c:		return -1;
syscall/temp2.c:	if (curproc->p_filetable == NULL) {
syscall/temp2.c:		curproc->p_filetable = filetable_create();
syscall/temp2.c:		if (curproc->p_filetable == NULL) {
syscall/temp2.c:	l -= (argc - 1) * sizeCharPointer;
syscall/temp2.c:	as_destroy(curproc->p_addrspace);
syscall/temp2.c:		return -1;
syscall/temp2.c:		argv[i] = (userptr_t) stackptr - total_len;	// keep track of string start
syscall/temp2.c:		result = copyoutstr(args_buffer+offset, (userptr_t) stackptr - total_len, str_size, NULL);
syscall/temp2.c:	pad = ((stackptr - total_len) - ((argc + 1) * sizeCharPointer)) % 8;
syscall/temp2.c:	stackptr = (stackptr - total_len) - pad;
syscall/temp2.c:	stackptr -= sizeCharPointer;
syscall/temp2.c:		return -1;
syscall/temp2.c:	for(i = argc - 1; i >= 0; i--) {
syscall/temp2.c:		stackptr -= sizeCharPointer;
syscall/temp2.c:                        return -1;
syscall/temp2.c:	return -1;
syscall/temp2.c:		return -1;
syscall/temp2.c:		return -1;
syscall/waitpid.c:		return -1;
syscall/waitpid.c:	l = array_get(lock_table, pid-1);
syscall/waitpid.c:		return -1;
syscall/waitpid.c:	struct pid_list *temp = curproc->children;
syscall/waitpid.c:		if(pid == temp->pid) {
syscall/waitpid.c:		temp = temp->next;
syscall/waitpid.c:		return -1;
syscall/waitpid.c:	if(temp->exited != 0){	// process already exited so return immediately
syscall/waitpid.c:		c = array_get(cv_table, pid-1);
syscall/waitpid.c:		temp->waiting = 1;	// let child know parent is waiting	
syscall/waitpid.c:			if(WIFEXITED(temp->exitcode))
syscall/waitpid.c:				*status = WEXITSTATUS(temp->exitcode);
syscall/waitpid.c:			else if(WIFSIGNALED(temp->exitcode))
syscall/waitpid.c:				*status = WTERMSIG(temp->exitcode);
syscall/waitpid.c:			else if(WIFSTOPPED(temp->exitcode))
syscall/waitpid.c:				*status = WSTOPSIG(temp->exitcode);
syscall/waitpid.c:				*status = temp->exitcode;
syscall/temp3.c: * minutiae, like the vfs-level open destroying pathnames.
syscall/temp3.c:	filetable_placeat(curproc->p_filetable, newfile, fd, &oldfile);
syscall/temp3.c:			return -1;
syscall/temp3.c:				return -1;
syscall/temp3.c:				return -1;	
syscall/temp3.c:		return -1;
syscall/temp3.c:	if (curproc->p_filetable == NULL) {
syscall/temp3.c:		curproc->p_filetable = filetable_create();
syscall/temp3.c:		if (curproc->p_filetable == NULL) {
syscall/temp3.c:	l -= (argc - 1) * sizeCharPointer;
syscall/temp3.c:	as_destroy(curproc->p_addrspace);
syscall/temp3.c:		return -1;
syscall/temp3.c:		//argv[i] = (userptr_t) stackptr - total_len;	// keep track of string start
syscall/temp3.c:		result = copyoutstr(args_buffer+offset, (userptr_t) stackptr - total_len, str_size, NULL);
syscall/temp3.c:	pad = ((stackptr - total_len) - ((argc + 1) * sizeCharPointer)) % 8;
syscall/temp3.c:	stack_offset = (stackptr - total_len) - pad;
syscall/temp3.c:	stack_offset -= sizeCharPointer;
syscall/temp3.c:		return -1;
syscall/temp3.c:	stack_offset -= argc * sizeCharPointer;
syscall/temp3.c:		kprintf("\ns: %s\n", (char *)str_addr-total_len);
syscall/temp3.c:		result = copyout((const void *) (&str_addr - total_len), (userptr_t)stack_offset, sizeCharPointer);
syscall/temp3.c:			return -1;
syscall/temp3.c:	return -1;
syscall/temp3.c:		return -1;
syscall/temp3.c:		return -1;
syscall/fork.c:		return -1;
syscall/fork.c:        if(pid == -1) { // no more pids
syscall/fork.c:	child->pid = pid + 1;
syscall/fork.c:	child->parent = curproc;
syscall/fork.c:	parents_child->pid = pid+1;
syscall/fork.c:	parents_child->exitcode = 0;
syscall/fork.c:	parents_child->waiting = 0;
syscall/fork.c:	parents_child->exited = 0;
syscall/fork.c:	parents_child->next = curproc->children;	
syscall/fork.c:	curproc->children = parents_child;
syscall/fork.c:	result = as_copy(curproc->p_addrspace, &child->p_addrspace);
syscall/fork.c:		lock_release(child->lock);
syscall/fork.c:		lock_release(child->lock);
syscall/fork.c:		parents_child = curproc->children;
syscall/fork.c:		curproc->children = curproc->children->next;
syscall/fork.c:		return -1;
syscall/exit.c:	l = array_get(lock_table, curproc->pid-1);
syscall/exit.c:	c = array_get(cv_table, curproc->pid-1);
syscall/exit.c:	if(curproc->parent != NULL)
syscall/exit.c:		temp = curproc->parent->children;
syscall/exit.c:		if(temp->pid == curproc->pid) {
syscall/exit.c:			temp->exitcode = _MKWAIT_EXIT(exitcode);
syscall/exit.c:			temp->exited = 1;
syscall/exit.c:		temp = temp->next;
syscall/exit.c:	if(temp != NULL && temp->waiting == 1) {
syscall/exit.c:        while(curproc->children != NULL) {
syscall/exit.c:		tofree = curproc->children;
syscall/exit.c:                curproc->children = curproc->children->next;  
syscall/exit.c:	curproc->children = NULL;
test/arraytest.c:		array_set(a, i, &testarray[TESTSIZE-i-1]);
test/arraytest.c:		KASSERT(*p == TESTSIZE-i-1);
test/arraytest.c:		KASSERT(*p == TESTSIZE-i-1);
test/arraytest.c:	for (i=1; i<TESTSIZE/2 - 1; i++) {
test/arraytest.c:		KASSERT(*p == TESTSIZE-i-2);
test/arraytest.c:	KASSERT(*p == TESTSIZE-1);
test/arraytest.c:	KASSERT(*p == TESTSIZE-1);
test/arraytest.c:	KASSERT(*p == TESTSIZE-3);
test/arraytest.c:	KASSERT(*p == TESTSIZE-1);
test/arraytest.c:	KASSERT(*p == TESTSIZE-1);
test/fstest.c: * fstest - filesystem test code
test/fstest.c:#define SLOGAN   "HODIE MIHI - CRAS TIBI\n"
test/fstest.c:			ch = ch - 'A';
test/fstest.c:		return -1;
test/fstest.c:		return -1;
test/fstest.c:			return -1;
test/fstest.c:			return -1;
test/fstest.c:		bytes += (ku.uio_offset - pos);
test/fstest.c:		return -1;
test/fstest.c:		return -1;
test/fstest.c:			return -1;
test/fstest.c:			return -1;
test/fstest.c:		rotate(buf, -i);
test/fstest.c:			return -1;
test/fstest.c:		return -1;
test/fstest.c:		snprintf(numstr, sizeof(numstr), "%lu-%d", num, i);
test/fstest.c:		snprintf(namesuffix, sizeof(namesuffix), "%lu-%d", num, i);
test/fstest.c:		snprintf(namesuffix, sizeof(namesuffix), "%lu-%d", num, i);
test/fstest.c:		rotate(buf, -i);
test/fstest.c:		snprintf(namesuffix, sizeof(namesuffix), "%lu-%d", num, i);
test/fstest.c:	if (device[strlen(device)-1]==':') {
test/fstest.c:		device[strlen(device)-1] = 0;
test/fstest.c:		uio_kinit(&iov, &ku, buf, sizeof(buf)-ku.uio_resid, wpos,
test/kmalloctest.c:#include "opt-dumbvm.h"
test/kmalloctest.c: * pointers returned by kmalloc we first allocate a two-level radix
test/kmalloctest.c: * whole-page allocations.)
test/kmalloctest.c: * pointers (on a 32-bit machine) or 512 (on a 64-bit machine) and so
test/kmalloctest.c:		totalsize -= cursize;
test/synchtest.c:			/* ts2 -= ts1 */
test/synchtest.c:					"busy-looping\n");
test/synchtest.c:		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
test/synchtest.c:	testval1 = NTHREADS-1;
test/threadlisttest.c:	t->t_name = kstrdup(name);
test/threadlisttest.c:	if (t->t_name == NULL) {
test/threadlisttest.c:	t->t_stack = FAKE_MAGIC;
test/threadlisttest.c:	threadlistnode_init(&t->t_listnode, t);
test/threadlisttest.c:	KASSERT(t->t_stack == FAKE_MAGIC);
test/threadlisttest.c:	threadlistnode_cleanup(&t->t_listnode);
test/threadlisttest.c:	kfree(t->t_name);
test/threadlisttest.c:		cmp = strcmp(prev, t->t_name);
test/threadlisttest.c:		prev = t->t_name;
test/threadlisttest.c:	KASSERT(fakethreads[4]->t_listnode.tln_prev->tln_self ==
test/threadlisttest.c:	KASSERT(fakethreads[3]->t_listnode.tln_prev->tln_self ==
test/threadlisttest.c:	KASSERT(fakethreads[2]->t_listnode.tln_prev->tln_self ==
test/threadlisttest.c:	KASSERT(fakethreads[1]->t_listnode.tln_prev->tln_self ==
test/threadlisttest.c:		KASSERT(t == fakethreads[NUMNAMES - i - 1]);
test/tt3.c:#include "opt-synchprobs.h"
test/tt3.c:				m1->m[i][j] = rand >> 16;
test/tt3.c:				m2->m[i][j] = rand & 0xffff;
test/tt3.c:					tot += m1->m[i][k] * m2->m[k][j];
test/tt3.c:				m3->m[i][j] = tot;
test/tt3.c:			tot += m3->m[i][i];
thread/clock.c: * skimp on that because we have a known-good hardware clock.
thread/clock.c:	curcpu->c_hardclocks++;
thread/clock.c:	if ((curcpu->c_hardclocks % MIGRATE_HARDCLOCKS) == 0) {
thread/clock.c:	if ((curcpu->c_hardclocks % SCHEDULE_HARDCLOCKS) == 0) {
thread/clock.c:		num_secs--;
thread/spinlock.c:/* Make sure to build out-of-line versions of inline functions */
thread/spinlock.c:	spinlock_data_set(&splk->splk_lock, 0);
thread/spinlock.c:	splk->splk_holder = NULL;
thread/spinlock.c:	KASSERT(splk->splk_holder == NULL);
thread/spinlock.c:	KASSERT(spinlock_data_get(&splk->splk_lock) == 0);
thread/spinlock.c: * might come back to this lock and deadlock), then use a machine-level
thread/spinlock.c:		mycpu = curcpu->c_self;
thread/spinlock.c:		if (splk->splk_holder == mycpu) {
thread/spinlock.c:		mycpu->c_spinlocks++;
thread/spinlock.c:		 * Do test-test-and-set, that is, read first before
thread/spinlock.c:		 * doing test-and-set, to reduce bus contention.
thread/spinlock.c:		 * Test-and-set is a machine-level atomic operation
thread/spinlock.c:		if (spinlock_data_get(&splk->splk_lock) != 0) {
thread/spinlock.c:		if (spinlock_data_testandset(&splk->splk_lock) != 0) {
thread/spinlock.c:	splk->splk_holder = mycpu;
thread/spinlock.c:		KASSERT(splk->splk_holder == curcpu->c_self);
thread/spinlock.c:		KASSERT(curcpu->c_spinlocks > 0);
thread/spinlock.c:		curcpu->c_spinlocks--;
thread/spinlock.c:	splk->splk_holder = NULL;
thread/spinlock.c:	spinlock_data_set(&splk->splk_lock, 0);
thread/spinlock.c:	return (splk->splk_holder == curcpu->c_self);
thread/spl.c:/* Make sure to build out-of-line versions of spl inline functions */
thread/spl.c: * Machine-independent interrupt handling functions.
thread/spl.c: * Traditionally, all this code is machine-dependent.
thread/spl.c: * complicated -- but nearly all of this code could remain MI.
thread/spl.c: * curthread->t_iplhigh_count is used to track this.
thread/spl.c:	if (cur->t_iplhigh_count == 0) {
thread/spl.c:	cur->t_iplhigh_count++;
thread/spl.c:	cur->t_iplhigh_count--;
thread/spl.c:	if (cur->t_iplhigh_count == 0) {
thread/spl.c:	if (cur->t_curspl < spl) {
thread/spl.c:		splraise(cur->t_curspl, spl);
thread/spl.c:		ret = cur->t_curspl;
thread/spl.c:		cur->t_curspl = spl;
thread/spl.c:	else if (cur->t_curspl > spl) {
thread/spl.c:		ret = cur->t_curspl;
thread/spl.c:		cur->t_curspl = spl;
thread/synch.c:	sem->sem_name = kstrdup(name);
thread/synch.c:	if (sem->sem_name == NULL) {
thread/synch.c:	sem->sem_wchan = wchan_create(sem->sem_name);
thread/synch.c:	if (sem->sem_wchan == NULL) {
thread/synch.c:		kfree(sem->sem_name);
thread/synch.c:	spinlock_init(&sem->sem_lock);
thread/synch.c:	sem->sem_count = initial_count;
thread/synch.c:	spinlock_cleanup(&sem->sem_lock);
thread/synch.c:	wchan_destroy(sem->sem_wchan);
thread/synch.c:	kfree(sem->sem_name);
thread/synch.c:	KASSERT(curthread->t_in_interrupt == false);
thread/synch.c:	spinlock_acquire(&sem->sem_lock);
thread/synch.c:	while (sem->sem_count == 0) {
thread/synch.c:		 * strict ordering. Too bad. :-)
thread/synch.c:		wchan_sleep(sem->sem_wchan, &sem->sem_lock);
thread/synch.c:	KASSERT(sem->sem_count > 0);
thread/synch.c:	sem->sem_count--;
thread/synch.c:	spinlock_release(&sem->sem_lock);
thread/synch.c:	spinlock_acquire(&sem->sem_lock);
thread/synch.c:	sem->sem_count++;
thread/synch.c:	KASSERT(sem->sem_count > 0);
thread/synch.c:	wchan_wakeone(sem->sem_wchan, &sem->sem_lock);
thread/synch.c:	spinlock_release(&sem->sem_lock);
thread/synch.c:	lock->lk_name = kstrdup(name);
thread/synch.c:	if (lock->lk_name == NULL) {
thread/synch.c:	lock->lock_wchan = wchan_create(lock->lk_name);
thread/synch.c:	if (lock->lock_wchan == NULL) {
thread/synch.c:		kfree(lock->lk_name);
thread/synch.c:	spinlock_init(&lock->lock_spinlock);
thread/synch.c:	spinlock_cleanup(&lock->lock_spinlock);
thread/synch.c:	wchan_destroy(lock->lock_wchan);
thread/synch.c:	kfree(lock->lk_name);
thread/synch.c:	spinlock_acquire(&lock->lock_spinlock);
thread/synch.c:	while(TestAndSet(&lock->flag, 1) == 1)
thread/synch.c:		wchan_sleep(lock->lock_wchan, &lock->lock_spinlock);
thread/synch.c:	lock->holder = curthread;
thread/synch.c:	spinlock_release(&lock->lock_spinlock);
thread/synch.c:	spinlock_acquire(&lock->lock_spinlock);
thread/synch.c:		wchan_wakeone(lock->lock_wchan, &lock->lock_spinlock);
thread/synch.c:		lock->flag = 0;
thread/synch.c:		lock->holder = NULL;
thread/synch.c:	spinlock_release(&lock->lock_spinlock);
thread/synch.c:	return lock->flag == 1 && lock->holder == curthread; 
thread/synch.c:	cv->cv_name = kstrdup(name);
thread/synch.c:	if (cv->cv_name==NULL) {
thread/synch.c:	cv->cv_wchan = wchan_create(cv->cv_name);
thread/synch.c:	if (cv->cv_wchan == NULL) {
thread/synch.c:		kfree(cv->cv_name);
thread/synch.c:	spinlock_init(&cv->cv_spinlock);
thread/synch.c:	spinlock_cleanup(&cv->cv_spinlock);
thread/synch.c:	wchan_destroy(cv->cv_wchan);
thread/synch.c:	kfree(cv->cv_name);
thread/synch.c:	spinlock_acquire(&cv->cv_spinlock);
thread/synch.c:	wchan_sleep(cv->cv_wchan, &cv->cv_spinlock);		
thread/synch.c:	spinlock_release(&cv->cv_spinlock);
thread/synch.c:		spinlock_acquire(&cv->cv_spinlock);
thread/synch.c:		wchan_wakeone(cv->cv_wchan, &cv->cv_spinlock);
thread/synch.c:		spinlock_release(&cv->cv_spinlock);
thread/synch.c:		spinlock_acquire(&cv->cv_spinlock);
thread/synch.c:		wchan_wakeall(cv->cv_wchan, &cv->cv_spinlock);
thread/synch.c:		spinlock_release(&cv->cv_spinlock);
thread/threadlist.c:	tln->tln_next = NULL;
thread/threadlist.c:	tln->tln_prev = NULL;
thread/threadlist.c:	tln->tln_self = t;
thread/threadlist.c:	KASSERT(tln->tln_next == NULL);
thread/threadlist.c:	KASSERT(tln->tln_prev == NULL);
thread/threadlist.c:	KASSERT(tln->tln_self != NULL);
thread/threadlist.c:	tl->tl_head.tln_next = &tl->tl_tail;
thread/threadlist.c:	tl->tl_head.tln_prev = NULL;
thread/threadlist.c:	tl->tl_tail.tln_next = NULL;
thread/threadlist.c:	tl->tl_tail.tln_prev = &tl->tl_head;
thread/threadlist.c:	tl->tl_head.tln_self = NULL;
thread/threadlist.c:	tl->tl_tail.tln_self = NULL;
thread/threadlist.c:	tl->tl_count = 0;
thread/threadlist.c:	DEBUGASSERT(tl->tl_head.tln_next == &tl->tl_tail);
thread/threadlist.c:	DEBUGASSERT(tl->tl_head.tln_prev == NULL);
thread/threadlist.c:	DEBUGASSERT(tl->tl_tail.tln_next == NULL);
thread/threadlist.c:	DEBUGASSERT(tl->tl_tail.tln_prev == &tl->tl_head);
thread/threadlist.c:	DEBUGASSERT(tl->tl_head.tln_self == NULL);
thread/threadlist.c:	DEBUGASSERT(tl->tl_tail.tln_self == NULL);
thread/threadlist.c:	KASSERT(tl->tl_count == 0);
thread/threadlist.c:	return (tl->tl_count == 0);
thread/threadlist.c:	addee = &t->t_listnode;
thread/threadlist.c:	DEBUGASSERT(addee->tln_prev == NULL);
thread/threadlist.c:	DEBUGASSERT(addee->tln_next == NULL);
thread/threadlist.c:	addee->tln_prev = onlist;
thread/threadlist.c:	addee->tln_next = onlist->tln_next;
thread/threadlist.c:	addee->tln_prev->tln_next = addee;
thread/threadlist.c:	addee->tln_next->tln_prev = addee;
thread/threadlist.c:	addee = &t->t_listnode;
thread/threadlist.c:	DEBUGASSERT(addee->tln_prev == NULL);
thread/threadlist.c:	DEBUGASSERT(addee->tln_next == NULL);
thread/threadlist.c:	addee->tln_prev = onlist->tln_prev;
thread/threadlist.c:	addee->tln_next = onlist;
thread/threadlist.c:	addee->tln_prev->tln_next = addee;
thread/threadlist.c:	addee->tln_next->tln_prev = addee;
thread/threadlist.c:	DEBUGASSERT(tln->tln_prev != NULL);
thread/threadlist.c:	DEBUGASSERT(tln->tln_next != NULL);
thread/threadlist.c:	tln->tln_prev->tln_next = tln->tln_next;
thread/threadlist.c:	tln->tln_next->tln_prev = tln->tln_prev;
thread/threadlist.c:	tln->tln_prev = NULL;
thread/threadlist.c:	tln->tln_next = NULL;
thread/threadlist.c:	threadlist_insertafternode(&tl->tl_head, t);
thread/threadlist.c:	tl->tl_count++;
thread/threadlist.c:	threadlist_insertbeforenode(t, &tl->tl_tail);
thread/threadlist.c:	tl->tl_count++;
thread/threadlist.c:	tln = tl->tl_head.tln_next;
thread/threadlist.c:	if (tln->tln_next == NULL) {
thread/threadlist.c:	DEBUGASSERT(tl->tl_count > 0);
thread/threadlist.c:	tl->tl_count--;
thread/threadlist.c:	return tln->tln_self;
thread/threadlist.c:	tln = tl->tl_tail.tln_prev;
thread/threadlist.c:	if (tln->tln_prev == NULL) {
thread/threadlist.c:	DEBUGASSERT(tl->tl_count > 0);
thread/threadlist.c:	tl->tl_count--;
thread/threadlist.c:	return tln->tln_self;
thread/threadlist.c:	threadlist_insertafternode(&onlist->t_listnode, addee);
thread/threadlist.c:	tl->tl_count++;
thread/threadlist.c:	threadlist_insertbeforenode(addee, &onlist->t_listnode);
thread/threadlist.c:	tl->tl_count++;
thread/threadlist.c:	threadlist_removenode(&t->t_listnode);
thread/threadlist.c:	DEBUGASSERT(tl->tl_count > 0);
thread/threadlist.c:	tl->tl_count--;
thread/thread.c: * Core kernel-level thread system.
thread/thread.c:#include "opt-synchprobs.h"
thread/thread.c:/* Wait channel. A wchan is protected by an associated, passed-in spinlock. */
thread/thread.c:	((uint32_t *)thread->t_stack)[0] = THREAD_STACK_MAGIC;
thread/thread.c:	((uint32_t *)thread->t_stack)[1] = THREAD_STACK_MAGIC;
thread/thread.c:	((uint32_t *)thread->t_stack)[2] = THREAD_STACK_MAGIC;
thread/thread.c:	((uint32_t *)thread->t_stack)[3] = THREAD_STACK_MAGIC;
thread/thread.c: * Note that when ->t_stack is NULL, which is the case if the stack
thread/thread.c:	if (thread->t_stack != NULL) {
thread/thread.c:		KASSERT(((uint32_t*)thread->t_stack)[0] == THREAD_STACK_MAGIC);
thread/thread.c:		KASSERT(((uint32_t*)thread->t_stack)[1] == THREAD_STACK_MAGIC);
thread/thread.c:		KASSERT(((uint32_t*)thread->t_stack)[2] == THREAD_STACK_MAGIC);
thread/thread.c:		KASSERT(((uint32_t*)thread->t_stack)[3] == THREAD_STACK_MAGIC);
thread/thread.c:	thread->t_name = kstrdup(name);
thread/thread.c:	if (thread->t_name == NULL) {
thread/thread.c:	thread->t_wchan_name = "NEW";
thread/thread.c:	thread->t_state = S_READY;
thread/thread.c:	thread_machdep_init(&thread->t_machdep);
thread/thread.c:	threadlistnode_init(&thread->t_listnode, thread);
thread/thread.c:	thread->t_stack = NULL;
thread/thread.c:	thread->t_context = NULL;
thread/thread.c:	thread->t_cpu = NULL;
thread/thread.c:	thread->t_proc = NULL;
thread/thread.c:	thread->t_in_interrupt = false;
thread/thread.c:	thread->t_curspl = IPL_HIGH;
thread/thread.c:	thread->t_iplhigh_count = 1; /* corresponding to t_curspl */
thread/thread.c:	c->c_self = c;
thread/thread.c:	c->c_hardware_number = hardware_number;
thread/thread.c:	c->c_curthread = NULL;
thread/thread.c:	threadlist_init(&c->c_zombies);
thread/thread.c:	c->c_hardclocks = 0;
thread/thread.c:	c->c_spinlocks = 0;
thread/thread.c:	c->c_isidle = false;
thread/thread.c:	threadlist_init(&c->c_runqueue);
thread/thread.c:	spinlock_init(&c->c_runqueue_lock);
thread/thread.c:	c->c_ipi_pending = 0;
thread/thread.c:	c->c_numshootdown = 0;
thread/thread.c:	spinlock_init(&c->c_ipi_lock);
thread/thread.c:	result = cpuarray_add(&allcpus, c, &c->c_number);
thread/thread.c:	snprintf(namebuf, sizeof(namebuf), "<boot #%d>", c->c_number);
thread/thread.c:	c->c_curthread = thread_create(namebuf);
thread/thread.c:	if (c->c_curthread == NULL) {
thread/thread.c:	result = proc_addthread(kproc, c->c_curthread);
thread/thread.c:	if (c->c_number == 0) {
thread/thread.c:		 * Leave c->c_curthread->t_stack NULL for the boot
thread/thread.c:		/*c->c_curthread->t_stack = ... */
thread/thread.c:		c->c_curthread->t_stack = kmalloc(STACK_SIZE);
thread/thread.c:		if (c->c_curthread->t_stack == NULL) {
thread/thread.c:		thread_checkstack_init(c->c_curthread);
thread/thread.c:	c->c_curthread->t_cpu = c;
thread/thread.c:	KASSERT(thread->t_state != S_RUN);
thread/thread.c:	KASSERT(thread->t_proc == NULL);
thread/thread.c:	if (thread->t_stack != NULL) {
thread/thread.c:		kfree(thread->t_stack);
thread/thread.c:	threadlistnode_cleanup(&thread->t_listnode);
thread/thread.c:	thread_machdep_cleanup(&thread->t_machdep);
thread/thread.c:	thread->t_wchan_name = "DESTROYED";
thread/thread.c:	kfree(thread->t_name);
thread/thread.c: * The list of zombies is per-cpu.
thread/thread.c:	while ((z = threadlist_remhead(&curcpu->c_zombies)) != NULL) {
thread/thread.c:		KASSERT(z->t_state == S_ZOMBIE);
thread/thread.c:	curcpu->c_runqueue.tl_count = 0;
thread/thread.c:	curcpu->c_runqueue.tl_head.tln_next = &curcpu->c_runqueue.tl_tail;
thread/thread.c:	curcpu->c_runqueue.tl_tail.tln_prev = &curcpu->c_runqueue.tl_head;
thread/thread.c:	 * might be updated later by mainbus-type code. This also
thread/thread.c:	bootthread = bootcpu->c_curthread;
thread/thread.c:	 * Initializing curcpu and curthread is machine-dependent
thread/thread.c:	curthread->t_cpu = curcpu;
thread/thread.c:	curcpu->c_curthread = curthread;
thread/thread.c:	KASSERT(curthread->t_proc != NULL);
thread/thread.c:	KASSERT(curcpu->c_number == software_number);
thread/thread.c:	for (i=0; i<cpuarray_num(&allcpus) - 1; i++) {
thread/thread.c:	targetcpu = target->t_cpu;
thread/thread.c:		KASSERT(spinlock_do_i_hold(&targetcpu->c_runqueue_lock));
thread/thread.c:		spinlock_acquire(&targetcpu->c_runqueue_lock);
thread/thread.c:	target->t_state = S_READY;
thread/thread.c:	threadlist_addtail(&targetcpu->c_runqueue, target);
thread/thread.c:	if (targetcpu->c_isidle) {
thread/thread.c:		spinlock_release(&targetcpu->c_runqueue_lock);
thread/thread.c:	newthread->t_stack = kmalloc(STACK_SIZE);
thread/thread.c:	if (newthread->t_stack == NULL) {
thread/thread.c:	newthread->t_cpu = curthread->t_cpu;
thread/thread.c:		proc = curthread->t_proc;
thread/thread.c:	proc->numthreads++;
thread/thread.c:	newthread->t_iplhigh_count++;
thread/thread.c: * High level, machine-independent context switch code.
thread/thread.c:	DEBUGASSERT(curcpu->c_curthread == curthread);
thread/thread.c:	DEBUGASSERT(curthread->t_cpu == curcpu->c_self);
thread/thread.c:	if (curcpu->c_isidle) {
thread/thread.c:	spinlock_acquire(&curcpu->c_runqueue_lock);
thread/thread.c:	/* Micro-optimization: if nothing to do, just return */
thread/thread.c:	if (newstate == S_READY && threadlist_isempty(&curcpu->c_runqueue)) {
thread/thread.c:		spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c:		cur->t_wchan_name = wc->wc_name;
thread/thread.c:		threadlist_addtail(&wc->wc_threads, cur);
thread/thread.c:		cur->t_wchan_name = "ZOMBIE";
thread/thread.c:		threadlist_addtail(&curcpu->c_zombies, cur);
thread/thread.c:	cur->t_state = newstate;
thread/thread.c:	 * curcpu->c_isidle must be true when md_idle is
thread/thread.c:	 * *is* atomic with respect to re-enabling interrupts.
thread/thread.c:	curcpu->c_isidle = true;
thread/thread.c:		next = threadlist_remhead(&curcpu->c_runqueue);
thread/thread.c:			spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c:			spinlock_acquire(&curcpu->c_runqueue_lock);
thread/thread.c:	curcpu->c_isidle = false;
thread/thread.c:	 * Note that curcpu->c_curthread may be the same variable as
thread/thread.c:	curcpu->c_curthread = next;
thread/thread.c:	switchframe_switch(&cur->t_context, &next->t_context);
thread/thread.c:	 *    - The thread now currently running is "cur", not "next",
thread/thread.c:	 *    - "cur" is _not_ the thread that just *called*
thread/thread.c:	 *    - If newstate is S_ZOMB we never get back here in that
thread/thread.c:	 *    - If the thread just chosen to run ("next") was a new
thread/thread.c:	 *    - At this point the thread whose stack we're now on may
thread/thread.c:	cur->t_wchan_name = NULL;
thread/thread.c:	cur->t_state = S_RUN;
thread/thread.c:	spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c:	cur->t_wchan_name = NULL;
thread/thread.c:	cur->t_state = S_RUN;
thread/thread.c:	spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c:	KASSERT(cur->t_proc == NULL);
thread/thread.c:	KASSERT(cur->t_proc == NULL);
thread/thread.c:	 * round-robin fashion.
thread/thread.c: * something that needs to be tuned and probably is workload-specific.
thread/thread.c:		spinlock_acquire(&c->c_runqueue_lock);
thread/thread.c:		total_count += c->c_runqueue.tl_count;
thread/thread.c:		if (c == curcpu->c_self) {
thread/thread.c:			my_count = c->c_runqueue.tl_count;
thread/thread.c:		spinlock_release(&c->c_runqueue_lock);
thread/thread.c:	to_send = my_count - one_share;
thread/thread.c:	spinlock_acquire(&curcpu->c_runqueue_lock);
thread/thread.c:		t = threadlist_remtail(&curcpu->c_runqueue);
thread/thread.c:	spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c:		if (c == curcpu->c_self) {
thread/thread.c:		spinlock_acquire(&c->c_runqueue_lock);
thread/thread.c:		while (c->c_runqueue.tl_count < one_share && to_send > 0) {
thread/thread.c:			 *   - it went to sleep;
thread/thread.c:			 *   - the processor became idle, so it
thread/thread.c:			 *   - it was reawakened, so it was put on the
thread/thread.c:			 *   - and the processor hasn't fully unidled
thread/thread.c:				to_send--;
thread/thread.c:			t->t_cpu = c;
thread/thread.c:			threadlist_addtail(&c->c_runqueue, t);
thread/thread.c:			      "Migrated thread %s: cpu %u -> %u",
thread/thread.c:			      t->t_name, curcpu->c_number, c->c_number);
thread/thread.c:			to_send--;
thread/thread.c:			if (c->c_isidle) {
thread/thread.c:		spinlock_release(&c->c_runqueue_lock);
thread/thread.c:		spinlock_acquire(&curcpu->c_runqueue_lock);
thread/thread.c:			threadlist_addtail(&curcpu->c_runqueue, t);
thread/thread.c:		spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c: * This is what's displayed by ps -alx in Unix.
thread/thread.c:	threadlist_init(&wc->wc_threads);
thread/thread.c:	wc->wc_name = name;
thread/thread.c:	result = wchanarray_add(&allwchans, wc, &wc->wc_index);
thread/thread.c:		threadlist_cleanup(&wc->wc_threads);
thread/thread.c:	KASSERT(wchanarray_get(&allwchans, wc->wc_index) == wc);
thread/thread.c:	if (wc->wc_index < num - 1) {
thread/thread.c:		wc2 = wchanarray_get(&allwchans, num - 1);
thread/thread.c:		wchanarray_set(&allwchans, wc->wc_index, wc2);
thread/thread.c:		wc2->wc_index = wc->wc_index;
thread/thread.c:	wchanarray_setsize(&allwchans, num - 1);
thread/thread.c:	threadlist_cleanup(&wc->wc_threads);
thread/thread.c:	KASSERT(!curthread->t_in_interrupt);
thread/thread.c:	KASSERT(curcpu->c_spinlocks == 1);
thread/thread.c:	target = threadlist_remhead(&wc->wc_threads);
thread/thread.c:	while ((target = threadlist_remhead(&wc->wc_threads)) != NULL) {
thread/thread.c:	ret = threadlist_isempty(&wc->wc_threads);
thread/thread.c: * Machine-independent IPI handling
thread/thread.c: * Send an IPI (inter-processor interrupt) to the specified CPU.
thread/thread.c:	spinlock_acquire(&target->c_ipi_lock);
thread/thread.c:	target->c_ipi_pending |= (uint32_t)1 << code;
thread/thread.c:	spinlock_release(&target->c_ipi_lock);
thread/thread.c:		if (c != curcpu->c_self) {
thread/thread.c:	spinlock_acquire(&target->c_ipi_lock);
thread/thread.c:	n = target->c_numshootdown;
thread/thread.c:		target->c_numshootdown = TLBSHOOTDOWN_ALL;
thread/thread.c:		target->c_shootdown[n] = *mapping;
thread/thread.c:		target->c_numshootdown = n+1;
thread/thread.c:	target->c_ipi_pending |= (uint32_t)1 << IPI_TLBSHOOTDOWN;
thread/thread.c:	spinlock_release(&target->c_ipi_lock);
thread/thread.c:	spinlock_acquire(&curcpu->c_ipi_lock);
thread/thread.c:	bits = curcpu->c_ipi_pending;
thread/thread.c:		/* panic on another cpu - just stop dead */
thread/thread.c:		spinlock_release(&curcpu->c_ipi_lock);
thread/thread.c:		spinlock_release(&curcpu->c_ipi_lock);
thread/thread.c:		spinlock_acquire(&curcpu->c_runqueue_lock);
thread/thread.c:		if (!curcpu->c_isidle) {
thread/thread.c:				curcpu->c_number);
thread/thread.c:		spinlock_release(&curcpu->c_runqueue_lock);
thread/thread.c:		kprintf("cpu%d: offline.\n", curcpu->c_number);
thread/thread.c:		if (curcpu->c_numshootdown == TLBSHOOTDOWN_ALL) {
thread/thread.c:			for (i=0; i<curcpu->c_numshootdown; i++) {
thread/thread.c:				vm_tlbshootdown(&curcpu->c_shootdown[i]);
thread/thread.c:		curcpu->c_numshootdown = 0;
thread/thread.c:	curcpu->c_ipi_pending = 0;
thread/thread.c:	spinlock_release(&curcpu->c_ipi_lock);
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	/* nothing - device continues to exist even when not in use */
vfs/device.c:	if (d->d_blocks > 0) {
vfs/device.c:		if ((pos % d->d_blocksize)!=0) {
vfs/device.c:			/* not block-aligned */
vfs/device.c:		if (pos / d->d_blocksize >= d->d_blocks) {
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	result = dev_tryseek(d, uio->uio_offset);
vfs/device.c:	KASSERT(uio->uio_rw == UIO_READ);
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	result = dev_tryseek(d, uio->uio_offset);
vfs/device.c:	KASSERT(uio->uio_rw == UIO_WRITE);
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	if (d->d_blocks > 0) {
vfs/device.c:		statbuf->st_size = d->d_blocks * d->d_blocksize;
vfs/device.c:		statbuf->st_blksize = d->d_blocksize;
vfs/device.c:		statbuf->st_size = 0;
vfs/device.c:	result = VOP_GETTYPE(v, &statbuf->st_mode);
vfs/device.c:	statbuf->st_mode |= 0600;
vfs/device.c:	statbuf->st_nlink = 1;
vfs/device.c:	statbuf->st_blocks = d->d_blocks;
vfs/device.c:	statbuf->st_dev = 0;
vfs/device.c:	statbuf->st_rdev = d->d_devnumber;
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	if (d->d_blocks > 0) {
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	if (d->d_blocks == 0) {
vfs/device.c: * For fsync() - meaningless, do nothing.
vfs/device.c:	struct device *d = v->vn_data;
vfs/device.c:	if (d->d_blocks > 0 && (off_t)(d->d_blocks*d->d_blocksize) == len) {
vfs/devnull.c:	if (uio->uio_rw == UIO_WRITE) {
vfs/devnull.c:		uio->uio_resid = 0;
vfs/devnull.c:	dev->d_ops = &null_devops;
vfs/devnull.c:	dev->d_blocks = 0;
vfs/devnull.c:	dev->d_blocksize = 1;
vfs/devnull.c:	dev->d_devnumber = 0; /* assigned by vfs_adddev */
vfs/devnull.c:	dev->d_data = NULL;
vfs/vfscwd.c:	spinlock_acquire(&curproc->p_lock);
vfs/vfscwd.c:	if (curproc->p_cwd!=NULL) {
vfs/vfscwd.c:		VOP_INCREF(curproc->p_cwd);
vfs/vfscwd.c:		*ret = curproc->p_cwd;
vfs/vfscwd.c:	spinlock_release(&curproc->p_lock);
vfs/vfscwd.c:	spinlock_acquire(&curproc->p_lock);
vfs/vfscwd.c:	old = curproc->p_cwd;
vfs/vfscwd.c:	curproc->p_cwd = dir;
vfs/vfscwd.c:	spinlock_release(&curproc->p_lock);
vfs/vfscwd.c:	spinlock_acquire(&curproc->p_lock);
vfs/vfscwd.c:	old = curproc->p_cwd;
vfs/vfscwd.c:	curproc->p_cwd = NULL;
vfs/vfscwd.c:	spinlock_release(&curproc->p_lock);
vfs/vfscwd.c:	KASSERT(uio->uio_rw==UIO_READ);
vfs/vfscwd.c:	KASSERT(cwd->vn_fs != NULL);
vfs/vfscwd.c:	name = FSOP_GETVOLNAME(cwd->vn_fs);
vfs/vfscwd.c:		name = vfs_getdevname(cwd->vn_fs);
vfs/vfsfail.c: * to a op-specific args structure, so they're all the same type)
vfs/vfslist.c: * kd_name    - Name of device (eg, "lhd0"). Should always be set to
vfs/vfslist.c: * kd_rawname - Name of raw device (eg, "lhd0raw"). Is non-NULL if and
vfs/vfslist.c: * kd_device  - Device object this name refers to. May be NULL if kd_fs
vfs/vfslist.c: * kd_fs      - Filesystem object mounted on, or associated with, this
vfs/vfslist.c:	vfs_biglock_depth--;
vfs/vfslist.c: * Global sync function - call FSOP_SYNC on all devices.
vfs/vfslist.c:		if (dev->kd_fs != NULL) {
vfs/vfslist.c:			/*result =*/ FSOP_SYNC(dev->kd_fs);
vfs/vfslist.c:		if (kd->kd_fs!=NULL) {
vfs/vfslist.c:			volname = FSOP_GETVOLNAME(kd->kd_fs);
vfs/vfslist.c:			if (!strcmp(kd->kd_name, devname) ||
vfs/vfslist.c:				return FSOP_GETROOT(kd->kd_fs, ret);
vfs/vfslist.c:			if (kd->kd_rawname!=NULL &&
vfs/vfslist.c:			    !strcmp(kd->kd_name, devname)) {
vfs/vfslist.c:		if (!strcmp(kd->kd_name, devname)) {
vfs/vfslist.c:			KASSERT(kd->kd_fs==NULL);
vfs/vfslist.c:			KASSERT(kd->kd_rawname==NULL);
vfs/vfslist.c:			KASSERT(kd->kd_device != NULL);
vfs/vfslist.c:			VOP_INCREF(kd->kd_vnode);
vfs/vfslist.c:			*ret = kd->kd_vnode;
vfs/vfslist.c:		if (kd->kd_rawname!=NULL && !strcmp(kd->kd_rawname, devname)) {
vfs/vfslist.c:			KASSERT(kd->kd_device != NULL);
vfs/vfslist.c:			VOP_INCREF(kd->kd_vnode);
vfs/vfslist.c:			*ret = kd->kd_vnode;
vfs/vfslist.c:		if (kd->kd_fs == fs) {
vfs/vfslist.c:			return kd->kd_name;
vfs/vfslist.c:		if (kd->kd_fs) {
vfs/vfslist.c:			volname = FSOP_GETVOLNAME(kd->kd_fs);
vfs/vfslist.c:		if (samestring3(kd->kd_rawname, n1, n2, n3) ||
vfs/vfslist.c:		    samestring3(kd->kd_name, n1, n2, n3)) {
vfs/vfslist.c:	kd->kd_name = name;
vfs/vfslist.c:	kd->kd_rawname = rawname;
vfs/vfslist.c:	kd->kd_device = dev;
vfs/vfslist.c:	kd->kd_vnode = vnode;
vfs/vfslist.c:	kd->kd_fs = fs;
vfs/vfslist.c:		dev->d_devnumber = index+1;
vfs/vfslist.c:		if (dev->kd_rawname==NULL) {
vfs/vfslist.c:		if (!strcmp(devname, dev->kd_name)) {
vfs/vfslist.c:	if (kd->kd_fs != NULL) {
vfs/vfslist.c:	KASSERT(kd->kd_rawname != NULL);
vfs/vfslist.c:	KASSERT(kd->kd_device != NULL);
vfs/vfslist.c:	result = mountfunc(data, kd->kd_device, &fs);
vfs/vfslist.c:	kd->kd_fs = fs;
vfs/vfslist.c:		volname ? volname : kd->kd_name, kd->kd_name);
vfs/vfslist.c:	if (kd->kd_fs == NULL) {
vfs/vfslist.c:	KASSERT(kd->kd_rawname != NULL);
vfs/vfslist.c:	KASSERT(kd->kd_device != NULL);
vfs/vfslist.c:	result = FSOP_SYNC(kd->kd_fs);
vfs/vfslist.c:	result = FSOP_UNMOUNT(kd->kd_fs);
vfs/vfslist.c:	kprintf("vfs: Unmounted %s:\n", kd->kd_name);
vfs/vfslist.c:	kd->kd_fs = NULL;
vfs/vfslist.c:		if (dev->kd_rawname == NULL) {
vfs/vfslist.c:		if (dev->kd_fs == NULL) {
vfs/vfslist.c:		kprintf("vfs: Unmounting %s:\n", dev->kd_name);
vfs/vfslist.c:		result = FSOP_SYNC(dev->kd_fs);
vfs/vfslist.c:				"again\n", dev->kd_name, strerror(result));
vfs/vfslist.c:			result = FSOP_SYNC(dev->kd_fs);
vfs/vfslist.c:					dev->kd_name, strerror(result));
vfs/vfslist.c:		result = FSOP_UNMOUNT(dev->kd_fs);
vfs/vfslist.c:				dev->kd_name);
vfs/vfslist.c:				dev->kd_name, strerror(result));
vfs/vfslist.c:		dev->kd_fs = NULL;
vfs/vfslookup.c:	snprintf(tmp, sizeof(tmp)-1, "%s", fsname);
vfs/vfslookup.c:	int slash=-1, colon=-1, i;
vfs/vfslookup.c:		/* device:path - get root of device's filesystem */
vfs/vfslookup.c:			/* device:/path - skip slash, treat as device:path */
vfs/vfslookup.c:		KASSERT(vn->vn_fs!=NULL);
vfs/vfslookup.c:		result = FSOP_GETROOT(vn->vn_fs, startvn);
vfs/vfslookup.c: * Name-to-vnode translation.
vfs/vfspath.c: * High-level VFS operations on pathnames.
vfs/vfspath.c:	 * effort to not fail. If it does fail - such as on a hard I/O
vfs/vfspath.c:	 * error or something - vnode.c prints a warning. The reason
vfs/vfspath.c:	if (olddir->vn_fs==NULL || newdir->vn_fs==NULL ||
vfs/vfspath.c:	    olddir->vn_fs != newdir->vn_fs) {
vfs/vfspath.c:	if (oldfile->vn_fs==NULL || newdir->vn_fs==NULL ||
vfs/vfspath.c:	    oldfile->vn_fs != newdir->vn_fs) {
vfs/vnode.c:	vn->vn_ops = ops;
vfs/vnode.c:	vn->vn_refcount = 1;
vfs/vnode.c:	spinlock_init(&vn->vn_countlock);
vfs/vnode.c:	vn->vn_fs = fs;
vfs/vnode.c:	vn->vn_data = fsdata;
vfs/vnode.c:	KASSERT(vn->vn_refcount == 1);
vfs/vnode.c:	spinlock_cleanup(&vn->vn_countlock);
vfs/vnode.c:	vn->vn_ops = NULL;
vfs/vnode.c:	vn->vn_refcount = 0;
vfs/vnode.c:	vn->vn_fs = NULL;
vfs/vnode.c:	vn->vn_data = NULL;
vfs/vnode.c:	spinlock_acquire(&vn->vn_countlock);
vfs/vnode.c:	vn->vn_refcount++;
vfs/vnode.c:	spinlock_release(&vn->vn_countlock);
vfs/vnode.c:	spinlock_acquire(&vn->vn_countlock);
vfs/vnode.c:	KASSERT(vn->vn_refcount > 0);
vfs/vnode.c:	if (vn->vn_refcount > 1) {
vfs/vnode.c:		vn->vn_refcount--;
vfs/vnode.c:	spinlock_release(&vn->vn_countlock);
vfs/vnode.c:	if (v->vn_ops == NULL) {
vfs/vnode.c:	if (v->vn_ops == (void *)0xdeadbeef) {
vfs/vnode.c:	if (v->vn_ops->vop_magic != VOP_MAGIC) {
vfs/vnode.c:		      opstr, v->vn_ops->vop_magic);
vfs/vnode.c:	//if (v->vn_fs == NULL) {
vfs/vnode.c:	if (v->vn_fs == (void *)0xdeadbeef) {
vfs/vnode.c:	spinlock_acquire(&v->vn_countlock);
vfs/vnode.c:	if (v->vn_refcount < 0) {
vfs/vnode.c:		      v->vn_refcount);
vfs/vnode.c:	else if (v->vn_refcount == 0) {
vfs/vnode.c:	else if (v->vn_refcount > 0x100000) {
vfs/vnode.c:			opstr, v->vn_refcount);
vfs/vnode.c:	spinlock_release(&v->vn_countlock);
vm/copyinout.c: * addresses are supplied by user-level code. This code is itself
vm/copyinout.c: * machine-independent; it uses the machine-dependent C setjmp/longjmp
vm/copyinout.c: * (2) It assumes that the user-space region of memory is contiguous
vm/copyinout.c: * instance, that the processor honors read-only bits on memory pages
vm/copyinout.c: * (4) It assumes that if a proper user-space address that is valid
vm/copyinout.c: * (5) It assumes that the machine-dependent trap logic provides and
vm/copyinout.c: * assumption 3), this code cannot be used, and cpu- or platform-
vm/copyinout.c: * machine-dependent code.)
vm/copyinout.c:	longjmp(curthread->t_machdep.tm_copyjmp, 1);
vm/copyinout.c: * Assumes userspace runs from 0 through USERSPACETOP-1.
vm/copyinout.c:	top = bot+len-1;
vm/copyinout.c:		*stoplen = USERSPACETOP - bot;
vm/copyinout.c: * Copy a block of memory of length LEN from user-level address USERSRC
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c: * user-level address USERDEST. We can use memcpy because it's
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c: * Copies a null-terminated string of maximum length MAXLEN from SRC
vm/copyinout.c: * there. Both lengths include the null-terminator. If the string
vm/copyinout.c:		/* ran into user-kernel boundary */
vm/copyinout.c: * Copy a string from user-level address USERSRC to kernel address
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c: * Copy a string from kernel address SRC to user-level address
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = copyfail;
vm/copyinout.c:	result = setjmp(curthread->t_machdep.tm_copyjmp);
vm/copyinout.c:		curthread->t_machdep.tm_badfaultfunc = NULL;
vm/copyinout.c:	curthread->t_machdep.tm_badfaultfunc = NULL;
vm/kmalloc.c:// Pool-based subpage allocator.
vm/kmalloc.c: * to catch simple off-the-end accesses. By default the guard bands
vm/kmalloc.c: * malloc-related bugs to manifest differently.
vm/kmalloc.c:#define PR_PAGEADDR(pr)  ((pr)->pageaddr_and_blocktype & PAGE_FRAME)
vm/kmalloc.c:#define PR_BLOCKTYPE(pr) ((pr)->pageaddr_and_blocktype & ~PAGE_FRAME)
vm/kmalloc.c: * logic per-cpu is worthwhile for scalability; however, for the time
vm/kmalloc.c: * OS/161 performance and scalability aren't super-critical.
vm/kmalloc.c:	KASSERT(root->page == NULL);
vm/kmalloc.c:	if (root->page != NULL) {
vm/kmalloc.c:		KASSERT(root->page != NULL);
vm/kmalloc.c:	root->page = (struct pagerefpage *)va;
vm/kmalloc.c:		if (root->numinuse >= NPAGEREFS_PER_PAGE) {
vm/kmalloc.c:			if (root->pagerefs_inuse[i]==0xffffffff) {
vm/kmalloc.c:				if ((root->pagerefs_inuse[i] & k)==0) {
vm/kmalloc.c:					root->pagerefs_inuse[i] |= k;
vm/kmalloc.c:					root->numinuse++;
vm/kmalloc.c:					if (root->page == NULL) {
vm/kmalloc.c:					if (root->page == NULL) {
vm/kmalloc.c:					return &root->page->refs[i*32 + j];
vm/kmalloc.c:		page = root->page;
vm/kmalloc.c:			KASSERT(root->numinuse == 0);
vm/kmalloc.c:		j = p-page->refs;
vm/kmalloc.c:			KASSERT((root->pagerefs_inuse[i] & k) != 0);
vm/kmalloc.c:			root->pagerefs_inuse[i] &= ~k;
vm/kmalloc.c:			KASSERT(root->numinuse > 0);
vm/kmalloc.c:			root->numinuse--;
vm/kmalloc.c:	highguard = lowguard + blocksize - 4;
vm/kmalloc.c:	highguard = blockaddr + blocksize - 4;
vm/kmalloc.c: *    - that the page is within MIPS_KSEG0 (for mips)
vm/kmalloc.c: *    - that the freelist starting point in PR is valid
vm/kmalloc.c: *    - that the number of free blocks is consistent with the freelist
vm/kmalloc.c: *    - that each freelist next pointer points within the page
vm/kmalloc.c: *    - that no freelist pointer points to the middle of a block
vm/kmalloc.c: *    - that free blocks are still deadbeefed (if CHECKBEEF)
vm/kmalloc.c: *    - that the freelist is not circular
vm/kmalloc.c: *    - that the guard bands are intact on all allocated blocks (if
vm/kmalloc.c:	if (pr->freelist_offset == INVALID_OFFSET) {
vm/kmalloc.c:		KASSERT(pr->nfree==0);
vm/kmalloc.c:	smallerblocksize = blktype > 0 ? sizes[blktype - 1] : 0;
vm/kmalloc.c:	KASSERT(pr->freelist_offset < PAGE_SIZE);
vm/kmalloc.c:	KASSERT(pr->freelist_offset % blocksize == 0);
vm/kmalloc.c:	fla = prpage + pr->freelist_offset;
vm/kmalloc.c:	for (; fl != NULL; fl = fl->next) {
vm/kmalloc.c:		KASSERT((fla-prpage) % blocksize == 0);
vm/kmalloc.c:		blocknum = (fla-prpage) / blocksize;
vm/kmalloc.c:		KASSERT(fl->next != fl);
vm/kmalloc.c:	KASSERT(nfree==pr->nfree);
vm/kmalloc.c:		for (pr = sizebases[i]; pr != NULL; pr = pr->next_samesize) {
vm/kmalloc.c:	for (pr = allbase; pr != NULL; pr = pr->next_all) {
vm/kmalloc.c:	ml->label = label;
vm/kmalloc.c:	ml->generation = mallocgeneration;
vm/kmalloc.c:	fl = (struct freelist *)(prpage + pr->freelist_offset);
vm/kmalloc.c:	for (; fl != NULL; fl = fl->next) {
vm/kmalloc.c:		i = ((vaddr_t)fl - prpage) / blocksize;
vm/kmalloc.c:		if (ml->generation != generation) {
vm/kmalloc.c:			blocksize, (void *)blockaddr, (void *)ml->label);
vm/kmalloc.c:		for (pr = sizebases[i]; pr != NULL; pr = pr->next_samesize) {
vm/kmalloc.c:	if (pr->freelist_offset != INVALID_OFFSET) {
vm/kmalloc.c:		fla = prpage + pr->freelist_offset;
vm/kmalloc.c:		for (; fl != NULL; fl = fl->next) {
vm/kmalloc.c:			index = (fla-prpage) / sizes[blktype];
vm/kmalloc.c:	kprintf("at 0x%08lx: size %-4lu  %u/%u free\n",
vm/kmalloc.c:		(unsigned) pr->nfree, n);
vm/kmalloc.c:		if (i%64==63 && i<n-1) {
vm/kmalloc.c:	for (pr = allbase; pr != NULL; pr = pr->next_all) {
vm/kmalloc.c:	for (guy = &sizebases[blktype]; *guy; guy = &(*guy)->next_samesize) {
vm/kmalloc.c:			*guy = pr->next_samesize;
vm/kmalloc.c:	for (guy = &allbase; *guy; guy = &(*guy)->next_all) {
vm/kmalloc.c:			*guy = pr->next_all;
vm/kmalloc.c: * warrant a whole-page allocation.
vm/kmalloc.c:	for (pr = sizebases[blktype]; pr != NULL; pr = pr->next_samesize) {
vm/kmalloc.c:		if (pr->nfree > 0) {
vm/kmalloc.c:			KASSERT(pr->freelist_offset < PAGE_SIZE);
vm/kmalloc.c:			fla = prpage + pr->freelist_offset;
vm/kmalloc.c:			fl = fl->next;
vm/kmalloc.c:			pr->nfree--;
vm/kmalloc.c:				KASSERT(pr->nfree > 0);
vm/kmalloc.c:				KASSERT(fla - prpage < PAGE_SIZE);
vm/kmalloc.c:				pr->freelist_offset = fla - prpage;
vm/kmalloc.c:				KASSERT(pr->nfree == 0);
vm/kmalloc.c:				pr->freelist_offset = INVALID_OFFSET;
vm/kmalloc.c:	pr->pageaddr_and_blocktype = MKPAB(prpage, blktype);
vm/kmalloc.c:	pr->nfree = PAGE_SIZE / sizes[blktype];
vm/kmalloc.c:	fl->next = NULL;
vm/kmalloc.c:	for (i=1; i<pr->nfree; i++) {
vm/kmalloc.c:		fl->next = (struct freelist *)(fla + (i-1)*sizes[blktype]);
vm/kmalloc.c:		KASSERT(fl != fl->next);
vm/kmalloc.c:	pr->freelist_offset = fla - prpage;
vm/kmalloc.c:	KASSERT(pr->freelist_offset == (pr->nfree-1)*sizes[blktype]);
vm/kmalloc.c:	pr->next_samesize = sizebases[blktype];
vm/kmalloc.c:	pr->next_all = allbase;
vm/kmalloc.c: * pointer is not on any heap page we recognize, return -1.
vm/kmalloc.c:		 * With guard bands, all client-facing subpage
vm/kmalloc.c:		 * page-aligned. So a page-aligned pointer is not one
vm/kmalloc.c:		return -1;
vm/kmalloc.c:	ptraddr -= GUARD_PTROFFSET;
vm/kmalloc.c:		return -1;
vm/kmalloc.c:	ptraddr -= LABEL_PTROFFSET;
vm/kmalloc.c:	for (pr = allbase; pr; pr = pr->next_all) {
vm/kmalloc.c:		/* Not on any of our pages - not a subpage allocation */
vm/kmalloc.c:		return -1;
vm/kmalloc.c:	offset = ptraddr - prpage;
vm/kmalloc.c:	smallerblocksize = blktype > 0 ? sizes[blktype - 1] : 0;
vm/kmalloc.c:	if (pr->freelist_offset == INVALID_OFFSET) {
vm/kmalloc.c:		fl->next = NULL;
vm/kmalloc.c:		fl->next = (struct freelist *)(prpage + pr->freelist_offset);
vm/kmalloc.c:			for (fl2 = fl->next; fl2 != NULL; fl2 = fl2->next) {
vm/kmalloc.c:		KASSERT(fl != fl->next);
vm/kmalloc.c:	pr->freelist_offset = offset;
vm/kmalloc.c:	pr->nfree++;
vm/kmalloc.c:	KASSERT(pr->nfree <= PAGE_SIZE / sizes[blktype]);
vm/kmalloc.c:	if (pr->nfree == PAGE_SIZE / sizes[blktype]) {
vm/kmalloc.c:		npages = (sz + PAGE_SIZE - 1)/PAGE_SIZE;
vm/addrspace.c:	as->as_vbase1 = 0;
vm/addrspace.c:	as->as_pbase1 = 0;
vm/addrspace.c:	as->as_stackpbase = 0;
vm/addrspace.c:	newas->as_vbase1 = old->as_vbase1;
vm/addrspace.c:	newas->as_npages1 = old->as_npages1;
vm/addrspace.c:	KASSERT(newas->as_pbase1 != 0);
vm/addrspace.c:        KASSERT(newas->as_stackpbase != 0);
vm/addrspace.c:	memmove((void *)PADDR_TO_KVADDR(newas->as_pbase1),
vm/addrspace.c:                (const void *)PADDR_TO_KVADDR(old->as_pbase1),
vm/addrspace.c:                old->as_npages1*PAGE_SIZE);
vm/addrspace.c:        memmove((void *)PADDR_TO_KVADDR(newas->as_stackpbase),
vm/addrspace.c:                (const void *)PADDR_TO_KVADDR(old->as_stackpbase),
vm/addrspace.c:	if(as->as_pbase1 != 0)
vm/addrspace.c:		free_kpages(PADDR_TO_KVADDR(as->as_pbase1));
vm/addrspace.c:	if(as->as_stackpbase != 0)
vm/addrspace.c:		free_kpages(PADDR_TO_KVADDR(as->as_stackpbase));
vm/addrspace.c:        sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
vm/addrspace.c:	if (as->as_vbase1 == 0) {
vm/addrspace.c:                as->as_vbase1 = vaddr;
vm/addrspace.c:                as->as_npages1 = npages;
vm/addrspace.c:	KASSERT(as->as_pbase1 == 0);
vm/addrspace.c:        KASSERT(as->as_stackpbase == 0);
vm/addrspace.c:	as->as_pbase1 = KVADDR_TO_PADDR(alloc_kpages(as->as_npages1));
vm/addrspace.c:        if (as->as_pbase1 == 0) {
vm/addrspace.c:	as->as_stackpbase = KVADDR_TO_PADDR(alloc_kpages(VM_STACKPAGES));
vm/addrspace.c:	if (as->as_stackpbase == 0) {
vm/addrspace.c:	as_zero_region(as->as_pbase1, as->as_npages1);
vm/addrspace.c:        as_zero_region(as->as_stackpbase, VM_STACKPAGES);
vm/addrspace.c:	/* Initial user-level stack pointer */
